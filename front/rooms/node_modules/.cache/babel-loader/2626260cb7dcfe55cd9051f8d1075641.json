{"ast":null,"code":"import { _ as _assert_this_initialized } from \"@swc/helpers/_/_assert_this_initialized\";\nimport { _ as _class_call_check } from \"@swc/helpers/_/_class_call_check\";\nimport { _ as _create_class } from \"@swc/helpers/_/_create_class\";\nimport { _ as _define_property } from \"@swc/helpers/_/_define_property\";\nimport { _ as _inherits } from \"@swc/helpers/_/_inherits\";\nimport { _ as _object_spread } from \"@swc/helpers/_/_object_spread\";\nimport { _ as _object_spread_props } from \"@swc/helpers/_/_object_spread_props\";\nimport { _ as _object_without_properties } from \"@swc/helpers/_/_object_without_properties\";\nimport { _ as _to_consumable_array } from \"@swc/helpers/_/_to_consumable_array\";\nimport { _ as _create_super } from \"@swc/helpers/_/_create_super\";\nimport * as React from \"react\";\nimport { classNames } from \"@vkontakte/vkjs\";\nimport { withContext } from \"../../hoc/withContext\";\nimport { withPlatform } from \"../../hoc/withPlatform\";\nimport { canUseDOM, withDOM } from \"../../lib/dom\";\nimport { getNavId } from \"../../lib/getNavId\";\nimport { Platform } from \"../../lib/platform\";\nimport { animationEvent, transitionEvent } from \"../../lib/supportEvents\";\nimport { warnOnce } from \"../../lib/warnOnce\";\nimport { ScrollContext } from \"../AppRoot/ScrollContext\";\nimport { ConfigProviderContext } from \"../ConfigProvider/ConfigProviderContext\";\nimport { NavViewIdContext } from \"../NavIdContext/NavIdContext\";\nimport { NavTransitionProvider } from \"../NavTransitionContext/NavTransitionContext\";\nimport { NavTransitionDirectionProvider } from \"../NavTransitionDirectionContext/NavTransitionDirectionContext\";\nimport { SplitColContext } from \"../SplitCol/SplitColContext\";\nimport { Touch } from \"../Touch/Touch\";\nimport { getSwipeBackPredicates, hasHorizontalScrollableElementWithScrolledToLeft, swipeBackExcluded } from \"./utils\";\nvar warn = warnOnce(\"ViewInfinite\");\nvar SwipeBackResults;\n(function (SwipeBackResults) {\n  SwipeBackResults[SwipeBackResults[\"fail\"] = 1] = \"fail\";\n  SwipeBackResults[SwipeBackResults[\"success\"] = 2] = \"success\";\n})(SwipeBackResults || (SwipeBackResults = {}));\nexport var scrollsCache = {};\nvar _React_Component;\nvar ViewInfiniteComponent = /*#__PURE__*/function (_superClass) {\n  \"use strict\";\n\n  _inherits(ViewInfiniteComponent, _superClass);\n  var _super = _create_super(ViewInfiniteComponent);\n  function ViewInfiniteComponent(props) {\n    _class_call_check(this, ViewInfiniteComponent);\n    var _this;\n    _this = _super.call(this, props);\n    _define_property(_assert_this_initialized(_this), \"swipeBackPrevented\", false);\n    _define_property(_assert_this_initialized(_this), \"scrolls\", scrollsCache[getNavId(_this.props, warn)] || {});\n    _define_property(_assert_this_initialized(_this), \"transitionFinishTimeout\", undefined);\n    _define_property(_assert_this_initialized(_this), \"animationFinishTimeout\", undefined);\n    _define_property(_assert_this_initialized(_this), \"panelNodes\", {});\n    _define_property(_assert_this_initialized(_this), \"transitionEndHandler\", function (e) {\n      if ((!e || [\"vkuianimation-ios-next-forward\", \"vkuianimation-ios-prev-back\", \"vkuianimation-view-next-forward\", \"vkuianimation-view-prev-back\"].includes(e.animationName)) && _this.state.prevPanel !== null) {\n        _this.flushTransition(_this.state.prevPanel, Boolean(_this.state.isBack));\n      }\n    });\n    _define_property(_assert_this_initialized(_this), \"swipingBackTransitionEndHandler\", function (e) {\n      // indexOf because of vendor prefixes in old browsers\n      if (!e || e.propertyName.includes(\"transform\") && e.target === _this.pickPanel(_this.state.swipeBackNextPanel)) {\n        switch (_this.state.swipeBackResult) {\n          case 1:\n            _this.onSwipeBackCancel();\n            break;\n          case 2:\n            _this.onSwipeBackSuccess();\n        }\n      }\n    });\n    _define_property(_assert_this_initialized(_this), \"handleTouchMoveXForNativeIOSSwipeBackOrSwipeNext\", function (event) {\n      if (_this.state.browserSwipe) {\n        return;\n      }\n      var _getSwipeBackPredicates = getSwipeBackPredicates(event.startX, event.shiftX, _this.window.innerWidth),\n        swipeBackTriggered = _getSwipeBackPredicates.swipeBackTriggered,\n        viewportStartEdgeTouched = _getSwipeBackPredicates.viewportStartEdgeTouched,\n        viewportEndEdgeTouched = _getSwipeBackPredicates.viewportEndEdgeTouched;\n      if ((viewportStartEdgeTouched || viewportEndEdgeTouched) && swipeBackTriggered) {\n        _this.setState({\n          browserSwipe: true\n        });\n      }\n    });\n    _define_property(_assert_this_initialized(_this), \"handleTouchMoveXForIOSSwipeBackSimulation\", function (event) {\n      if (_this.swipeBackPrevented || swipeBackExcluded(event)) {\n        return;\n      }\n      var _getSwipeBackPredicates = getSwipeBackPredicates(event.startX, event.shiftX, _this.window.innerWidth),\n        swipedToOpposite = _getSwipeBackPredicates.swipedToOpposite,\n        swipeBackTriggered = _getSwipeBackPredicates.swipeBackTriggered,\n        viewportStartEdgeTouched = _getSwipeBackPredicates.viewportStartEdgeTouched;\n      if (_this.state.animated && swipeBackTriggered) {\n        return;\n      }\n      if (!_this.state.swipingBack && _this.props.history && _this.props.history.length > 1) {\n        if (swipedToOpposite) {\n          _this.swipeBackPrevented = true;\n          return;\n        }\n        if (!swipeBackTriggered) {\n          return;\n        }\n        if (!viewportStartEdgeTouched && hasHorizontalScrollableElementWithScrolledToLeft(event.originalEvent.target)) {\n          _this.swipeBackPrevented = true;\n          return;\n        }\n        // Начался свайп назад\n        if (_this.props.onSwipeBackStart) {\n          var payload = _this.props.onSwipeBackStart(_this.state.activePanel);\n          if (payload === \"prevent\") {\n            _this.swipeBackPrevented = true;\n            return;\n          }\n        }\n        if (_this.state.activePanel !== null) {\n          var _this_props_scroll;\n          // Note: вызываем закрытие клавиатуры. В iOS это нативное поведение при свайпе.\n          _this.blurActiveElement();\n          var prevScrolls = _this.scrolls[_this.state.activePanel] || [];\n          _this.scrolls = _object_spread_props(_object_spread({}, _this.scrolls), _define_property({}, _this.state.activePanel, _to_consumable_array(prevScrolls).concat([(_this_props_scroll = _this.props.scroll) === null || _this_props_scroll === void 0 ? void 0 : _this_props_scroll.getScroll().y])));\n        }\n        _this.setState({\n          swipingBack: true,\n          swipeBackStartX: event.startX,\n          swipeBackPrevPanel: _this.state.activePanel,\n          swipeBackNextPanel: _this.props.history.slice(-2)[0]\n        });\n      }\n      if (_this.state.swipingBack) {\n        if (event.shiftX < 0) {\n          _this.setState({\n            swipeBackShift: 0\n          });\n        } else if (event.shiftX > _this.window.innerWidth - _this.state.swipeBackStartX) {\n          _this.setState({\n            swipeBackShift: _this.window.innerWidth\n          });\n        } else {\n          _this.setState({\n            swipeBackShift: event.shiftX\n          });\n        }\n      }\n    });\n    _define_property(_assert_this_initialized(_this), \"handleTouchEndForIOSSwipeBackSimulation\", function (event) {\n      _this.swipeBackPrevented = false;\n      if (_this.state.swipingBack && _this.window) {\n        var speed = _this.state.swipeBackShift / event.duration * 1000;\n        if (_this.state.swipeBackShift === 0) {\n          _this.onSwipeBackCancel();\n        } else if (_this.state.swipeBackShift >= _this.window.innerWidth) {\n          _this.onSwipeBackSuccess();\n        } else if (speed > 250 || _this.state.swipeBackShift >= _this.window.innerWidth / 2) {\n          _this.setState({\n            swipeBackResult: 2\n          });\n        } else {\n          _this.setState({\n            swipeBackResult: 1\n          });\n        }\n      }\n    });\n    _this.state = {\n      animated: false,\n      visiblePanels: [props.activePanel],\n      activePanel: props.activePanel,\n      isBack: undefined,\n      prevPanel: null,\n      nextPanel: null,\n      swipingBack: undefined,\n      swipeBackStartX: 0,\n      swipeBackShift: 0,\n      swipeBackNextPanel: null,\n      swipeBackPrevPanel: null,\n      swipeBackResult: null,\n      browserSwipe: false\n    };\n    return _this;\n  }\n  _create_class(ViewInfiniteComponent, [{\n    key: \"document\",\n    get: function get() {\n      return this.props.document;\n    }\n  }, {\n    key: \"window\",\n    get: function get() {\n      return this.props.window;\n    }\n  }, {\n    key: \"panels\",\n    get: function get() {\n      return React.Children.toArray(this.props.children);\n    }\n  }, {\n    key: \"componentWillUnmount\",\n    value: function componentWillUnmount() {\n      var id = getNavId(this.props);\n      if (id) {\n        scrollsCache[id] = this.scrolls;\n      }\n      if (this.animationFinishTimeout) {\n        clearTimeout(this.animationFinishTimeout);\n      }\n    }\n  }, {\n    key: \"componentDidUpdate\",\n    value: function componentDidUpdate(prevProps, prevState) {\n      var _this = this;\n      // Нужен переход\n      if (prevProps.activePanel !== this.props.activePanel && !prevState.swipingBack && !prevState.browserSwipe) {\n        var _this_props_scroll;\n        var isBack = false;\n        if (this.props.isBackCheck) {\n          isBack = this.props.isBackCheck({\n            from: prevProps.activePanel,\n            to: this.props.activePanel\n          });\n        } else {\n          var firstLayerId = this.panels.map(function (panel) {\n            return getNavId(panel.props, warn);\n          }).find(function (id) {\n            return id === prevProps.activePanel || id === _this.props.activePanel;\n          });\n          isBack = firstLayerId === this.props.activePanel;\n        }\n        this.blurActiveElement();\n        var prevScrolls = this.scrolls[prevProps.activePanel] || [];\n        var scrolls = _object_spread_props(_object_spread({}, this.scrolls), _define_property({}, prevProps.activePanel, _to_consumable_array(prevScrolls).concat([(_this_props_scroll = this.props.scroll) === null || _this_props_scroll === void 0 ? void 0 : _this_props_scroll.getScroll().y])));\n        this.scrolls = scrolls;\n        if (this.shouldDisableTransitionMotion()) {\n          this.flushTransition(prevProps.activePanel, isBack);\n        } else {\n          this.setState({\n            visiblePanels: [prevProps.activePanel, this.props.activePanel],\n            prevPanel: prevProps.activePanel,\n            nextPanel: this.props.activePanel,\n            activePanel: null,\n            animated: true,\n            isBack: isBack\n          });\n          // Фолбек анимации перехода\n          if (!animationEvent.supported) {\n            if (this.animationFinishTimeout) {\n              clearTimeout(this.animationFinishTimeout);\n            }\n            this.animationFinishTimeout = setTimeout(this.transitionEndHandler, this.props.platform === Platform.ANDROID || this.props.platform === Platform.VKCOM ? 300 : 600);\n          }\n        }\n      }\n      // Закончилась анимация свайпа назад\n      if (prevProps.activePanel !== this.props.activePanel && prevState.swipingBack) {\n        var nextPanel = this.state.swipeBackNextPanel;\n        var prevPanel = this.state.swipeBackPrevPanel;\n        var scrollPosition = undefined;\n        this.scrolls = _object_spread({}, this.scrolls);\n        if (prevPanel !== null) {\n          var prevPanelScrolls = _to_consumable_array(this.scrolls[prevPanel] || []).slice(0, -1);\n          this.scrolls[prevPanel] = prevPanelScrolls;\n        }\n        if (nextPanel !== null) {\n          var newPanelScrolls = _to_consumable_array(this.scrolls[nextPanel] || []);\n          scrollPosition = newPanelScrolls.pop();\n          this.scrolls[nextPanel] = newPanelScrolls;\n        }\n        this.setState({\n          swipeBackPrevPanel: null,\n          swipeBackNextPanel: null,\n          swipingBack: false,\n          swipeBackResult: null,\n          swipeBackStartX: 0,\n          swipeBackShift: 0,\n          activePanel: nextPanel,\n          visiblePanels: [nextPanel]\n        }, function () {\n          var _this_props_scroll;\n          (_this_props_scroll = _this.props.scroll) === null || _this_props_scroll === void 0 ? void 0 : _this_props_scroll.scrollTo(0, scrollPosition);\n          prevProps.onTransition && prevProps.onTransition({\n            isBack: true,\n            from: prevPanel,\n            to: nextPanel\n          });\n        });\n      }\n      // Началась анимация завершения свайпа назад.\n      if (!prevState.swipeBackResult && this.state.swipeBackResult) {\n        this.waitTransitionFinish(this.pickPanel(this.state.swipeBackNextPanel), this.swipingBackTransitionEndHandler);\n      }\n      // Если свайп назад отменился (когда пользователь недостаточно сильно свайпнул)\n      if (prevState.swipeBackResult === 1 && !this.state.swipeBackResult && this.state.activePanel !== null) {\n        var _this_props_scroll1;\n        var newPanelScrolls1 = _to_consumable_array(this.scrolls[this.state.activePanel] || []);\n        var scrollPosition1 = newPanelScrolls1.pop();\n        this.scrolls = _object_spread_props(_object_spread({}, this.scrolls), _define_property({}, this.state.activePanel, newPanelScrolls1));\n        (_this_props_scroll1 = this.props.scroll) === null || _this_props_scroll1 === void 0 ? void 0 : _this_props_scroll1.scrollTo(0, scrollPosition1);\n      }\n      // Закончился Safari свайп\n      if (prevProps.activePanel !== this.props.activePanel && this.state.browserSwipe) {\n        this.setState({\n          browserSwipe: false,\n          nextPanel: null,\n          prevPanel: null,\n          animated: false,\n          visiblePanels: [this.props.activePanel],\n          activePanel: this.props.activePanel\n        });\n      }\n    }\n  }, {\n    key: \"shouldDisableTransitionMotion\",\n    value: function shouldDisableTransitionMotion() {\n      var _this_props_configProvider, _this_props_splitCol;\n      return ((_this_props_configProvider = this.props.configProvider) === null || _this_props_configProvider === void 0 ? void 0 : _this_props_configProvider.transitionMotionEnabled) === false || !((_this_props_splitCol = this.props.splitCol) === null || _this_props_splitCol === void 0 ? void 0 : _this_props_splitCol.animate) || this.props.platform === Platform.VKCOM;\n    }\n  }, {\n    key: \"waitTransitionFinish\",\n    value: function waitTransitionFinish(elem, eventHandler) {\n      if (transitionEvent.supported && transitionEvent.name && elem) {\n        elem.removeEventListener(transitionEvent.name, eventHandler);\n        elem.addEventListener(transitionEvent.name, eventHandler);\n      } else {\n        if (this.transitionFinishTimeout) {\n          clearTimeout(this.transitionFinishTimeout);\n        }\n        this.transitionFinishTimeout = setTimeout(eventHandler, this.props.platform === Platform.ANDROID || this.props.platform === Platform.VKCOM ? 300 : 600);\n      }\n    }\n  }, {\n    key: \"blurActiveElement\",\n    value: function blurActiveElement() {\n      var _this_document;\n      if (typeof this.window !== \"undefined\" && ((_this_document = this.document) === null || _this_document === void 0 ? void 0 : _this_document.activeElement)) {\n        this.document.activeElement.blur();\n      }\n    }\n  }, {\n    key: \"pickPanel\",\n    value: function pickPanel(id) {\n      if (id === null) {\n        return undefined;\n      }\n      return this.panelNodes[id];\n    }\n  }, {\n    key: \"flushTransition\",\n    value: function flushTransition(prevPanel, isBack) {\n      var _this = this;\n      var activePanel = this.props.activePanel;\n      var prevPanelScrolls = _to_consumable_array(this.scrolls[prevPanel] || []).slice(0, -1);\n      var newPanelScrolls = _to_consumable_array(this.scrolls[activePanel] || []);\n      var scrollPosition = isBack ? newPanelScrolls.pop() : 0;\n      if (isBack) {\n        var _obj;\n        this.scrolls = _object_spread_props(_object_spread({}, this.scrolls), (_obj = {}, _define_property(_obj, prevPanel, prevPanelScrolls), _define_property(_obj, activePanel, newPanelScrolls), _obj));\n      }\n      this.setState({\n        prevPanel: null,\n        nextPanel: null,\n        visiblePanels: [activePanel],\n        activePanel: activePanel,\n        animated: false,\n        isBack: isBack\n      }, function () {\n        var _this_props_scroll;\n        (_this_props_scroll = _this.props.scroll) === null || _this_props_scroll === void 0 ? void 0 : _this_props_scroll.scrollTo(0, isBack ? scrollPosition : 0);\n        _this.props.onTransition && _this.props.onTransition({\n          isBack: isBack,\n          from: prevPanel,\n          to: activePanel\n        });\n      });\n    }\n  }, {\n    key: \"onSwipeBackSuccess\",\n    value: function onSwipeBackSuccess() {\n      this.props.onSwipeBack && this.props.onSwipeBack();\n    }\n  }, {\n    key: \"onSwipeBackCancel\",\n    value: function onSwipeBackCancel() {\n      this.props.onSwipeBackCancel && this.props.onSwipeBackCancel();\n      this.setState({\n        swipeBackPrevPanel: null,\n        swipeBackNextPanel: null,\n        swipingBack: false,\n        swipeBackResult: null,\n        swipeBackStartX: 0,\n        swipeBackShift: 0\n      });\n    }\n  }, {\n    key: \"calcPanelSwipeStyles\",\n    value: function calcPanelSwipeStyles(panelId) {\n      if (!canUseDOM || !this.window) {\n        return {};\n      }\n      var isPrev = panelId === this.state.swipeBackPrevPanel;\n      var isNext = panelId === this.state.swipeBackNextPanel;\n      if (!isPrev && !isNext || this.state.swipeBackResult) {\n        return {};\n      }\n      var prevPanelTranslate = \"\".concat(this.state.swipeBackShift, \"px\");\n      var nextPanelTranslate = \"\".concat(-50 + this.state.swipeBackShift * 100 / this.window.innerWidth / 2, \"%\");\n      var prevPanelShadow = 0.3 * (this.window.innerWidth - this.state.swipeBackShift) / this.window.innerWidth;\n      if (this.state.swipeBackResult) {\n        return isPrev ? {\n          boxShadow: \"-2px 0 12px rgba(0, 0, 0, \".concat(prevPanelShadow, \")\")\n        } : {};\n      }\n      if (isNext) {\n        return {\n          transform: \"translate3d(\".concat(nextPanelTranslate, \", 0, 0)\"),\n          WebkitTransform: \"translate3d(\".concat(nextPanelTranslate, \", 0, 0)\")\n        };\n      }\n      if (isPrev) {\n        return {\n          transform: \"translate3d(\".concat(prevPanelTranslate, \", 0, 0)\"),\n          WebkitTransform: \"translate3d(\".concat(prevPanelTranslate, \", 0, 0)\"),\n          boxShadow: \"-2px 0 12px rgba(0, 0, 0, \".concat(prevPanelShadow, \")\")\n        };\n      }\n      return {};\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this = this;\n      var _this_props = this.props,\n        platform = _this_props.platform,\n        _1 = _this_props.activePanel,\n        splitCol = _this_props.splitCol,\n        configProvider = _this_props.configProvider,\n        history = _this_props.history,\n        id = _this_props.id,\n        nav = _this_props.nav,\n        onTransition = _this_props.onTransition,\n        onSwipeBack = _this_props.onSwipeBack,\n        onSwipeBackStart = _this_props.onSwipeBackStart,\n        onSwipeBackCancel = _this_props.onSwipeBackCancel,\n        window = _this_props.window,\n        document = _this_props.document,\n        scroll = _this_props.scroll,\n        isBackCheck = _this_props.isBackCheck,\n        className = _this_props.className,\n        restProps = _object_without_properties(_this_props, [\"platform\", \"activePanel\", \"splitCol\", \"configProvider\", \"history\", \"id\", \"nav\", \"onTransition\", \"onSwipeBack\", \"onSwipeBackStart\", \"onSwipeBackCancel\", \"window\", \"document\", \"scroll\", \"isBackCheck\", \"className\"]);\n      var _this_state = this.state,\n        prevPanel = _this_state.prevPanel,\n        nextPanel = _this_state.nextPanel,\n        activePanel = _this_state.activePanel,\n        isBack = _this_state.isBack,\n        animated = _this_state.animated,\n        swipeBackPrevPanel = _this_state.swipeBackPrevPanel,\n        swipeBackNextPanel = _this_state.swipeBackNextPanel,\n        swipeBackResult = _this_state.swipeBackResult,\n        swipingBack = _this_state.swipingBack;\n      var panels = this.panels.filter(function (panel) {\n        var panelId = getNavId(panel.props, warn);\n        return panelId !== undefined && _this.state.visiblePanels.includes(panelId) || panelId === swipeBackPrevPanel || panelId === swipeBackNextPanel;\n      }).sort(function (panel) {\n        var panelId = getNavId(panel.props, warn);\n        var isPrevPanel = panelId === prevPanel || panelId === swipeBackPrevPanel;\n        var isNextPanel = panelId === nextPanel || panelId === swipeBackNextPanel;\n        if (isNextPanel) {\n          return swipingBack || _this.state.isBack ? -1 : 1;\n        }\n        if (isPrevPanel) {\n          return swipingBack || _this.state.isBack ? 1 : -1;\n        }\n        return 0;\n      });\n      var disableAnimation = this.shouldDisableTransitionMotion();\n      var iOSSwipeBackSimulationEnabled = !disableAnimation && platform === Platform.IOS && (configProvider === null || configProvider === void 0 ? void 0 : configProvider.isWebView) && Boolean(onSwipeBack);\n      return /*#__PURE__*/React.createElement(NavViewIdContext.Provider, {\n        value: id || nav\n      }, /*#__PURE__*/React.createElement(Touch, _object_spread_props(_object_spread({\n        Component: \"section\"\n      }, restProps), {\n        className: classNames(\"vkuiView\", platform === Platform.IOS && classNames(\"vkuiView--ios\", \"vkuiInternalView--ios\"), !disableAnimation && this.state.animated && \"vkuiView--animated\", !disableAnimation && this.state.swipingBack && \"vkuiView--swiping-back\", disableAnimation && \"vkuiView--no-motion\", className),\n        onMoveX: iOSSwipeBackSimulationEnabled ? this.handleTouchMoveXForIOSSwipeBackSimulation : platform === Platform.IOS ? this.handleTouchMoveXForNativeIOSSwipeBackOrSwipeNext : undefined,\n        onEnd: iOSSwipeBackSimulationEnabled ? this.handleTouchEndForIOSSwipeBackSimulation : undefined\n      }), /*#__PURE__*/React.createElement(\"div\", {\n        className: \"vkuiView__panels\"\n      }, panels.map(function (panel) {\n        var panelId = getNavId(panel.props, warn);\n        var isPrev = panelId === prevPanel || panelId === swipeBackPrevPanel;\n        var compensateScroll = isPrev || panelId === swipeBackNextPanel || panelId === nextPanel && isBack;\n        var isTransitionTarget = animated && panelId === (isBack ? prevPanel : nextPanel);\n        var scrollList = panelId && _this.scrolls[panelId] || [];\n        var scroll = scrollList[scrollList.length - 1] || 0;\n        return /*#__PURE__*/React.createElement(\"div\", {\n          className: classNames(\"vkuiView__panel\", panelId === activePanel && \"vkuiView__panel--active\", panelId === prevPanel && \"vkuiView__panel--prev\", panelId === nextPanel && \"vkuiView__panel--next\", panelId === swipeBackPrevPanel && \"vkuiView__panel--swipe-back-prev\", panelId === swipeBackNextPanel && \"vkuiView__panel--swipe-back-next\", swipeBackResult === 2 && \"vkuiView__panel--swipe-back-success\", swipeBackResult === 1 && \"vkuiView__panel--swipe-back-failed\"),\n          onAnimationEnd: isTransitionTarget ? _this.transitionEndHandler : undefined,\n          ref: function (el) {\n            return panelId !== undefined && (_this.panelNodes[panelId] = el);\n          },\n          style: _this.calcPanelSwipeStyles(panelId),\n          key: panelId\n        }, /*#__PURE__*/React.createElement(\"div\", {\n          className: \"vkuiView__panel-in\",\n          style: {\n            marginTop: compensateScroll ? -scroll : undefined\n          }\n        }, /*#__PURE__*/React.createElement(NavTransitionDirectionProvider, {\n          isBack: swipingBack || isBack\n        }, /*#__PURE__*/React.createElement(NavTransitionProvider, {\n          entering: panelId === nextPanel || panelId === swipeBackNextPanel\n        }, panel))));\n      }))));\n    }\n  }]);\n  return ViewInfiniteComponent;\n}(_React_Component = React.Component);\n_define_property(ViewInfiniteComponent, \"defaultProps\", {\n  history: []\n});\nexport var ViewInfinite = withContext(withContext(withContext(withPlatform(withDOM(ViewInfiniteComponent)), SplitColContext, \"splitCol\"), ConfigProviderContext, \"configProvider\"), ScrollContext, \"scroll\");","map":{"version":3,"names":["React","classNames","withContext","withPlatform","canUseDOM","withDOM","getNavId","Platform","animationEvent","transitionEvent","warnOnce","ScrollContext","ConfigProviderContext","NavViewIdContext","NavTransitionProvider","NavTransitionDirectionProvider","SplitColContext","Touch","getSwipeBackPredicates","hasHorizontalScrollableElementWithScrolledToLeft","swipeBackExcluded","warn","SwipeBackResults","scrollsCache","_React_Component","ViewInfiniteComponent","_superClass","props","_define_property","_assert_this_initialized","_this","undefined","e","includes","animationName","state","prevPanel","flushTransition","Boolean","isBack","propertyName","target","pickPanel","swipeBackNextPanel","swipeBackResult","onSwipeBackCancel","onSwipeBackSuccess","event","browserSwipe","_getSwipeBackPredicates","startX","shiftX","window","innerWidth","swipeBackTriggered","viewportStartEdgeTouched","viewportEndEdgeTouched","setState","swipeBackPrevented","swipedToOpposite","animated","swipingBack","history","length","originalEvent","onSwipeBackStart","payload","activePanel","_this_props_scroll","blurActiveElement","prevScrolls","scrolls","_object_spread_props","_object_spread","_to_consumable_array","concat","scroll","getScroll","y","swipeBackStartX","swipeBackPrevPanel","slice","swipeBackShift","speed","duration","visiblePanels","nextPanel","key","get","document","Children","toArray","children","componentWillUnmount","id","animationFinishTimeout","clearTimeout","componentDidUpdate","prevProps","prevState","isBackCheck","from","to","firstLayerId","panels","map","panel","find","shouldDisableTransitionMotion","supported","setTimeout","transitionEndHandler","platform","ANDROID","VKCOM","scrollPosition","prevPanelScrolls","newPanelScrolls","pop","scrollTo","onTransition","waitTransitionFinish","swipingBackTransitionEndHandler","_this_props_scroll1","newPanelScrolls1","scrollPosition1","_this_props_configProvider","_this_props_splitCol","configProvider","transitionMotionEnabled","splitCol","animate","elem","eventHandler","name","removeEventListener","addEventListener","transitionFinishTimeout","_this_document","activeElement","blur","panelNodes","_obj","onSwipeBack","calcPanelSwipeStyles","panelId","isPrev","isNext","prevPanelTranslate","nextPanelTranslate","prevPanelShadow","boxShadow","transform","WebkitTransform","render","_this_props","_1","nav","className","restProps","_object_without_properties","_this_state","filter","sort","isPrevPanel","isNextPanel","disableAnimation","iOSSwipeBackSimulationEnabled","IOS","isWebView","createElement","Provider","value","Component","onMoveX","handleTouchMoveXForIOSSwipeBackSimulation","handleTouchMoveXForNativeIOSSwipeBackOrSwipeNext","onEnd","handleTouchEndForIOSSwipeBackSimulation","compensateScroll","isTransitionTarget","scrollList","onAnimationEnd","ref","el","style","marginTop","entering","ViewInfinite"],"sources":["../../../src/components/View/ViewInfinite.tsx"],"sourcesContent":["import * as React from 'react';\nimport { classNames } from '@vkontakte/vkjs';\nimport { withContext } from '../../hoc/withContext';\nimport { withPlatform } from '../../hoc/withPlatform';\nimport { canUseDOM, DOMProps, withDOM } from '../../lib/dom';\nimport { getNavId, NavIdProps } from '../../lib/getNavId';\nimport { Platform } from '../../lib/platform';\nimport { animationEvent, transitionEvent } from '../../lib/supportEvents';\nimport { warnOnce } from '../../lib/warnOnce';\nimport { HasPlatform, HTMLAttributesWithRootRef } from '../../types';\nimport { ScrollContext, ScrollContextInterface } from '../AppRoot/ScrollContext';\nimport {\n  ConfigProviderContext,\n  ConfigProviderContextInterface,\n} from '../ConfigProvider/ConfigProviderContext';\nimport { NavViewIdContext } from '../NavIdContext/NavIdContext';\nimport { NavTransitionProvider } from '../NavTransitionContext/NavTransitionContext';\nimport { NavTransitionDirectionProvider } from '../NavTransitionDirectionContext/NavTransitionDirectionContext';\nimport { SplitColContext, SplitColContextProps } from '../SplitCol/SplitColContext';\nimport { Touch, TouchEvent } from '../Touch/Touch';\nimport {\n  getSwipeBackPredicates,\n  hasHorizontalScrollableElementWithScrolledToLeft,\n  swipeBackExcluded,\n} from './utils';\nimport styles from './View.module.css';\n\nconst warn = warnOnce('ViewInfinite');\n\nenum SwipeBackResults {\n  fail = 1,\n  success,\n}\n\ninterface Scrolls {\n  [index: string]: Array<number | undefined>;\n}\n\ninterface ViewsScrolls {\n  [index: string]: Scrolls;\n}\n\ntype TransitionEventHandler = (e?: TransitionEvent) => void;\n\nexport let scrollsCache: ViewsScrolls = {};\n\nexport type TransitionParams = { from: string | null; to: string | null };\n\nexport interface ViewInfiniteProps\n  extends HTMLAttributesWithRootRef<HTMLElement>,\n    HasPlatform,\n    NavIdProps {\n  activePanel: string;\n  onTransition?(params: TransitionParams & { isBack: boolean }): void;\n  /**\n   * callback свайпа назад\n   */\n  onSwipeBack?(): void;\n  /**\n   * callback начала анимации свайпа назад.\n   */\n  onSwipeBackStart?(activePanel: string | null): void | 'prevent';\n  /**\n   * callback завершения анимации отмененного пользователем свайпа\n   */\n  onSwipeBackCancel?(): void;\n  history?: string[];\n  isBackCheck?(params: TransitionParams): boolean;\n  /**\n   * @ignore\n   */\n  splitCol?: SplitColContextProps;\n  /**\n   * @ignore\n   */\n  configProvider?: ConfigProviderContextInterface;\n  /**\n   * @ignore\n   */\n  scroll?: ScrollContextInterface;\n}\n\nexport interface ViewInfiniteState {\n  animated: boolean;\n\n  visiblePanels: Array<string | null>;\n  activePanel: string | null;\n  isBack?: boolean;\n  prevPanel: string | null;\n  nextPanel: string | null;\n\n  swipingBack?: boolean;\n  swipeBackStartX: number;\n  swipeBackShift: number;\n  swipeBackNextPanel: string | null;\n  swipeBackPrevPanel: string | null;\n  swipeBackResult: SwipeBackResults | null;\n\n  browserSwipe: boolean;\n}\n\nclass ViewInfiniteComponent extends React.Component<\n  ViewInfiniteProps & DOMProps,\n  ViewInfiniteState\n> {\n  constructor(props: ViewInfiniteProps) {\n    super(props);\n\n    this.state = {\n      animated: false,\n\n      visiblePanels: [props.activePanel],\n      activePanel: props.activePanel,\n      isBack: undefined,\n      prevPanel: null,\n      nextPanel: null,\n\n      swipingBack: undefined,\n      swipeBackStartX: 0,\n      swipeBackShift: 0,\n      swipeBackNextPanel: null,\n      swipeBackPrevPanel: null,\n      swipeBackResult: null,\n\n      browserSwipe: false,\n    };\n  }\n\n  static defaultProps: Partial<ViewInfiniteProps> = {\n    history: [],\n  };\n\n  private swipeBackPrevented = false;\n  private scrolls = scrollsCache[getNavId(this.props, warn) as string] || {};\n  private transitionFinishTimeout: ReturnType<typeof setTimeout> | undefined = undefined;\n  private animationFinishTimeout: ReturnType<typeof setTimeout> | undefined = undefined;\n\n  get document() {\n    return this.props.document;\n  }\n\n  get window() {\n    return this.props.window;\n  }\n\n  get panels() {\n    return React.Children.toArray(this.props.children) as React.ReactElement[];\n  }\n\n  panelNodes: { [id: string]: HTMLDivElement | null } = {};\n\n  componentWillUnmount() {\n    const id = getNavId(this.props);\n    if (id) {\n      scrollsCache[id] = this.scrolls;\n    }\n    if (this.animationFinishTimeout) {\n      clearTimeout(this.animationFinishTimeout);\n    }\n  }\n\n  componentDidUpdate(prevProps: ViewInfiniteProps, prevState: ViewInfiniteState) {\n    // Нужен переход\n    if (\n      prevProps.activePanel !== this.props.activePanel &&\n      !prevState.swipingBack &&\n      !prevState.browserSwipe\n    ) {\n      let isBack = false;\n\n      if (this.props.isBackCheck) {\n        isBack = this.props.isBackCheck({\n          from: prevProps.activePanel,\n          to: this.props.activePanel,\n        });\n      } else {\n        const firstLayerId = this.panels\n          .map((panel) => getNavId(panel.props, warn))\n          .find((id) => id === prevProps.activePanel || id === this.props.activePanel);\n        isBack = firstLayerId === this.props.activePanel;\n      }\n\n      this.blurActiveElement();\n\n      const prevScrolls = this.scrolls[prevProps.activePanel] || [];\n      const scrolls = {\n        ...this.scrolls,\n        [prevProps.activePanel]: [...prevScrolls, this.props.scroll?.getScroll().y],\n      };\n      this.scrolls = scrolls;\n\n      if (this.shouldDisableTransitionMotion()) {\n        this.flushTransition(prevProps.activePanel, isBack);\n      } else {\n        this.setState({\n          visiblePanels: [prevProps.activePanel, this.props.activePanel],\n          prevPanel: prevProps.activePanel,\n          nextPanel: this.props.activePanel,\n          activePanel: null,\n          animated: true,\n          isBack,\n        });\n\n        // Фолбек анимации перехода\n        if (!animationEvent.supported) {\n          if (this.animationFinishTimeout) {\n            clearTimeout(this.animationFinishTimeout);\n          }\n          this.animationFinishTimeout = setTimeout(\n            this.transitionEndHandler,\n            this.props.platform === Platform.ANDROID || this.props.platform === Platform.VKCOM\n              ? 300\n              : 600,\n          );\n        }\n      }\n    }\n\n    // Закончилась анимация свайпа назад\n    if (prevProps.activePanel !== this.props.activePanel && prevState.swipingBack) {\n      const nextPanel = this.state.swipeBackNextPanel;\n      const prevPanel = this.state.swipeBackPrevPanel;\n      let scrollPosition: undefined | number = undefined;\n\n      this.scrolls = {\n        ...this.scrolls,\n      };\n\n      if (prevPanel !== null) {\n        const prevPanelScrolls = [...(this.scrolls[prevPanel] || [])].slice(0, -1);\n        this.scrolls[prevPanel] = prevPanelScrolls;\n      }\n      if (nextPanel !== null) {\n        const newPanelScrolls = [...(this.scrolls[nextPanel] || [])];\n        scrollPosition = newPanelScrolls.pop();\n        this.scrolls[nextPanel] = newPanelScrolls;\n      }\n\n      this.setState(\n        {\n          swipeBackPrevPanel: null,\n          swipeBackNextPanel: null,\n          swipingBack: false,\n          swipeBackResult: null,\n          swipeBackStartX: 0,\n          swipeBackShift: 0,\n          activePanel: nextPanel,\n          visiblePanels: [nextPanel],\n        },\n        () => {\n          this.props.scroll?.scrollTo(0, scrollPosition);\n          prevProps.onTransition &&\n            prevProps.onTransition({\n              isBack: true,\n              from: prevPanel,\n              to: nextPanel,\n            });\n        },\n      );\n    }\n\n    // Началась анимация завершения свайпа назад.\n    if (!prevState.swipeBackResult && this.state.swipeBackResult) {\n      this.waitTransitionFinish(\n        this.pickPanel(this.state.swipeBackNextPanel),\n        this.swipingBackTransitionEndHandler,\n      );\n    }\n\n    // Если свайп назад отменился (когда пользователь недостаточно сильно свайпнул)\n    if (\n      prevState.swipeBackResult === SwipeBackResults.fail &&\n      !this.state.swipeBackResult &&\n      this.state.activePanel !== null\n    ) {\n      const newPanelScrolls = [...(this.scrolls[this.state.activePanel] || [])];\n      const scrollPosition = newPanelScrolls.pop();\n      this.scrolls = {\n        ...this.scrolls,\n        [this.state.activePanel]: newPanelScrolls,\n      };\n\n      this.props.scroll?.scrollTo(0, scrollPosition);\n    }\n\n    // Закончился Safari свайп\n    if (prevProps.activePanel !== this.props.activePanel && this.state.browserSwipe) {\n      this.setState({\n        browserSwipe: false,\n        nextPanel: null,\n        prevPanel: null,\n        animated: false,\n        visiblePanels: [this.props.activePanel],\n        activePanel: this.props.activePanel,\n      });\n    }\n  }\n\n  shouldDisableTransitionMotion(): boolean {\n    return (\n      this.props.configProvider?.transitionMotionEnabled === false ||\n      !this.props.splitCol?.animate ||\n      this.props.platform === Platform.VKCOM\n    );\n  }\n\n  waitTransitionFinish(\n    elem: HTMLElement | null | undefined,\n    eventHandler: TransitionEventHandler,\n  ): void {\n    if (transitionEvent.supported && transitionEvent.name && elem) {\n      elem.removeEventListener(\n        transitionEvent.name as keyof HTMLElementEventMap,\n        eventHandler as EventListener,\n      );\n      elem.addEventListener(\n        transitionEvent.name as keyof HTMLElementEventMap,\n        eventHandler as EventListener,\n      );\n    } else {\n      if (this.transitionFinishTimeout) {\n        clearTimeout(this.transitionFinishTimeout);\n      }\n\n      this.transitionFinishTimeout = setTimeout(\n        eventHandler,\n        this.props.platform === Platform.ANDROID || this.props.platform === Platform.VKCOM\n          ? 300\n          : 600,\n      );\n    }\n  }\n\n  blurActiveElement(): void {\n    if (typeof this.window !== 'undefined' && this.document?.activeElement) {\n      (this.document.activeElement as HTMLElement).blur();\n    }\n  }\n\n  pickPanel(id: string | null) {\n    if (id === null) {\n      return undefined;\n    }\n    return this.panelNodes[id];\n  }\n\n  flushTransition(prevPanel: string, isBack: boolean) {\n    const activePanel = this.props.activePanel;\n\n    const prevPanelScrolls = [...(this.scrolls[prevPanel] || [])].slice(0, -1);\n    const newPanelScrolls = [...(this.scrolls[activePanel] || [])];\n    const scrollPosition = isBack ? newPanelScrolls.pop() : 0;\n    if (isBack) {\n      this.scrolls = {\n        ...this.scrolls,\n        [prevPanel]: prevPanelScrolls,\n        [activePanel]: newPanelScrolls,\n      };\n    }\n\n    this.setState(\n      {\n        prevPanel: null,\n        nextPanel: null,\n        visiblePanels: [activePanel],\n        activePanel: activePanel,\n        animated: false,\n        isBack,\n      },\n      () => {\n        this.props.scroll?.scrollTo(0, isBack ? scrollPosition : 0);\n        this.props.onTransition &&\n          this.props.onTransition({ isBack, from: prevPanel, to: activePanel });\n      },\n    );\n  }\n\n  transitionEndHandler = (e?: React.AnimationEvent): void => {\n    if (\n      (!e ||\n        [\n          styles['animation-ios-next-forward'],\n          styles['animation-ios-prev-back'],\n          styles['animation-view-next-forward'],\n          styles['animation-view-prev-back'],\n        ].includes(e.animationName)) &&\n      this.state.prevPanel !== null\n    ) {\n      this.flushTransition(this.state.prevPanel, Boolean(this.state.isBack));\n    }\n  };\n\n  swipingBackTransitionEndHandler = (e?: TransitionEvent): void => {\n    // indexOf because of vendor prefixes in old browsers\n    if (\n      !e ||\n      (e.propertyName.includes('transform') &&\n        e.target === this.pickPanel(this.state.swipeBackNextPanel))\n    ) {\n      switch (this.state.swipeBackResult) {\n        case SwipeBackResults.fail:\n          this.onSwipeBackCancel();\n          break;\n        case SwipeBackResults.success:\n          this.onSwipeBackSuccess();\n      }\n    }\n  };\n\n  onSwipeBackSuccess(): void {\n    this.props.onSwipeBack && this.props.onSwipeBack();\n  }\n\n  onSwipeBackCancel(): void {\n    this.props.onSwipeBackCancel && this.props.onSwipeBackCancel();\n    this.setState({\n      swipeBackPrevPanel: null,\n      swipeBackNextPanel: null,\n      swipingBack: false,\n      swipeBackResult: null,\n      swipeBackStartX: 0,\n      swipeBackShift: 0,\n    });\n  }\n\n  handleTouchMoveXForNativeIOSSwipeBackOrSwipeNext = (event: TouchEvent) => {\n    if (this.state.browserSwipe) {\n      return;\n    }\n    const { swipeBackTriggered, viewportStartEdgeTouched, viewportEndEdgeTouched } =\n      getSwipeBackPredicates(event.startX, event.shiftX, this.window!.innerWidth);\n\n    if ((viewportStartEdgeTouched || viewportEndEdgeTouched) && swipeBackTriggered) {\n      this.setState({ browserSwipe: true });\n    }\n  };\n\n  handleTouchMoveXForIOSSwipeBackSimulation = (event: TouchEvent) => {\n    if (this.swipeBackPrevented || swipeBackExcluded(event)) {\n      return;\n    }\n\n    const { swipedToOpposite, swipeBackTriggered, viewportStartEdgeTouched } =\n      getSwipeBackPredicates(event.startX, event.shiftX, this.window!.innerWidth);\n\n    if (this.state.animated && swipeBackTriggered) {\n      return;\n    }\n\n    if (!this.state.swipingBack && this.props.history && this.props.history.length > 1) {\n      if (swipedToOpposite) {\n        this.swipeBackPrevented = true;\n        return;\n      }\n\n      if (!swipeBackTriggered) {\n        return;\n      }\n\n      if (\n        !viewportStartEdgeTouched &&\n        hasHorizontalScrollableElementWithScrolledToLeft(event.originalEvent.target as HTMLElement)\n      ) {\n        this.swipeBackPrevented = true;\n        return;\n      }\n      // Начался свайп назад\n      if (this.props.onSwipeBackStart) {\n        const payload = this.props.onSwipeBackStart(this.state.activePanel);\n        if (payload === 'prevent') {\n          this.swipeBackPrevented = true;\n          return;\n        }\n      }\n\n      if (this.state.activePanel !== null) {\n        // Note: вызываем закрытие клавиатуры. В iOS это нативное поведение при свайпе.\n        this.blurActiveElement();\n        const prevScrolls = this.scrolls[this.state.activePanel] || [];\n        this.scrolls = {\n          ...this.scrolls,\n          [this.state.activePanel]: [...prevScrolls, this.props.scroll?.getScroll().y],\n        };\n      }\n\n      this.setState({\n        swipingBack: true,\n        swipeBackStartX: event.startX,\n        swipeBackPrevPanel: this.state.activePanel,\n        swipeBackNextPanel: this.props.history.slice(-2)[0],\n      });\n    }\n\n    if (this.state.swipingBack) {\n      if (event.shiftX < 0) {\n        this.setState({ swipeBackShift: 0 });\n      } else if (event.shiftX > this.window!.innerWidth - this.state.swipeBackStartX) {\n        this.setState({ swipeBackShift: this.window!.innerWidth });\n      } else {\n        this.setState({ swipeBackShift: event.shiftX });\n      }\n    }\n  };\n\n  handleTouchEndForIOSSwipeBackSimulation = (event: TouchEvent) => {\n    this.swipeBackPrevented = false;\n\n    if (this.state.swipingBack && this.window) {\n      const speed = (this.state.swipeBackShift / event.duration) * 1000;\n      if (this.state.swipeBackShift === 0) {\n        this.onSwipeBackCancel();\n      } else if (this.state.swipeBackShift >= this.window.innerWidth) {\n        this.onSwipeBackSuccess();\n      } else if (speed > 250 || this.state.swipeBackShift >= this.window.innerWidth / 2) {\n        this.setState({ swipeBackResult: SwipeBackResults.success });\n      } else {\n        this.setState({ swipeBackResult: SwipeBackResults.fail });\n      }\n    }\n  };\n\n  calcPanelSwipeStyles(panelId: string | undefined): React.CSSProperties {\n    if (!canUseDOM || !this.window) {\n      return {};\n    }\n\n    const isPrev = panelId === this.state.swipeBackPrevPanel;\n    const isNext = panelId === this.state.swipeBackNextPanel;\n\n    if ((!isPrev && !isNext) || this.state.swipeBackResult) {\n      return {};\n    }\n\n    let prevPanelTranslate = `${this.state.swipeBackShift}px`;\n    let nextPanelTranslate = `${\n      -50 + (this.state.swipeBackShift * 100) / this.window.innerWidth / 2\n    }%`;\n    let prevPanelShadow =\n      (0.3 * (this.window.innerWidth - this.state.swipeBackShift)) / this.window.innerWidth;\n\n    if (this.state.swipeBackResult) {\n      return isPrev ? { boxShadow: `-2px 0 12px rgba(0, 0, 0, ${prevPanelShadow})` } : {};\n    }\n\n    if (isNext) {\n      return {\n        transform: `translate3d(${nextPanelTranslate}, 0, 0)`,\n        WebkitTransform: `translate3d(${nextPanelTranslate}, 0, 0)`,\n      };\n    }\n    if (isPrev) {\n      return {\n        transform: `translate3d(${prevPanelTranslate}, 0, 0)`,\n        WebkitTransform: `translate3d(${prevPanelTranslate}, 0, 0)`,\n        boxShadow: `-2px 0 12px rgba(0, 0, 0, ${prevPanelShadow})`,\n      };\n    }\n\n    return {};\n  }\n\n  render() {\n    const {\n      platform,\n      activePanel: _1,\n      splitCol,\n      configProvider,\n      history,\n      id,\n      nav,\n      onTransition,\n      onSwipeBack,\n      onSwipeBackStart,\n      onSwipeBackCancel,\n      window,\n      document,\n      scroll,\n      isBackCheck,\n      className,\n      ...restProps\n    } = this.props;\n    const {\n      prevPanel,\n      nextPanel,\n      activePanel,\n      isBack,\n      animated,\n      swipeBackPrevPanel,\n      swipeBackNextPanel,\n      swipeBackResult,\n      swipingBack,\n    } = this.state;\n\n    const panels = this.panels\n      .filter((panel) => {\n        const panelId = getNavId(panel.props, warn);\n\n        return (\n          (panelId !== undefined && this.state.visiblePanels.includes(panelId)) ||\n          panelId === swipeBackPrevPanel ||\n          panelId === swipeBackNextPanel\n        );\n      })\n      .sort((panel) => {\n        const panelId = getNavId(panel.props, warn);\n        const isPrevPanel = panelId === prevPanel || panelId === swipeBackPrevPanel;\n        const isNextPanel = panelId === nextPanel || panelId === swipeBackNextPanel;\n\n        if (isNextPanel) {\n          return swipingBack || this.state.isBack ? -1 : 1;\n        }\n\n        if (isPrevPanel) {\n          return swipingBack || this.state.isBack ? 1 : -1;\n        }\n\n        return 0;\n      });\n\n    const disableAnimation = this.shouldDisableTransitionMotion();\n    const iOSSwipeBackSimulationEnabled =\n      !disableAnimation &&\n      platform === Platform.IOS &&\n      configProvider?.isWebView &&\n      Boolean(onSwipeBack);\n\n    return (\n      <NavViewIdContext.Provider value={id || nav}>\n        <Touch\n          Component=\"section\"\n          {...restProps}\n          className={classNames(\n            styles['View'],\n            platform === Platform.IOS && classNames(styles['View--ios'], 'vkuiInternalView--ios'),\n            !disableAnimation && this.state.animated && styles['View--animated'],\n            !disableAnimation && this.state.swipingBack && styles['View--swiping-back'],\n            disableAnimation && styles['View--no-motion'],\n            className,\n          )}\n          onMoveX={\n            iOSSwipeBackSimulationEnabled\n              ? this.handleTouchMoveXForIOSSwipeBackSimulation\n              : platform === Platform.IOS\n              ? this.handleTouchMoveXForNativeIOSSwipeBackOrSwipeNext\n              : undefined\n          }\n          onEnd={\n            iOSSwipeBackSimulationEnabled ? this.handleTouchEndForIOSSwipeBackSimulation : undefined\n          }\n        >\n          <div className={styles['View__panels']}>\n            {panels.map((panel: React.ReactElement) => {\n              const panelId = getNavId(panel.props, warn);\n              const isPrev = panelId === prevPanel || panelId === swipeBackPrevPanel;\n              const compensateScroll =\n                isPrev || panelId === swipeBackNextPanel || (panelId === nextPanel && isBack);\n              const isTransitionTarget = animated && panelId === (isBack ? prevPanel : nextPanel);\n              const scrollList = (panelId && this.scrolls[panelId]) || [];\n              const scroll = scrollList[scrollList.length - 1] || 0;\n\n              return (\n                <div\n                  className={classNames(\n                    styles['View__panel'],\n                    panelId === activePanel && styles['View__panel--active'],\n                    panelId === prevPanel && styles['View__panel--prev'],\n                    panelId === nextPanel && styles['View__panel--next'],\n                    panelId === swipeBackPrevPanel && styles['View__panel--swipe-back-prev'],\n                    panelId === swipeBackNextPanel && styles['View__panel--swipe-back-next'],\n                    swipeBackResult === SwipeBackResults.success &&\n                      styles['View__panel--swipe-back-success'],\n                    swipeBackResult === SwipeBackResults.fail &&\n                      styles['View__panel--swipe-back-failed'],\n                  )}\n                  onAnimationEnd={isTransitionTarget ? this.transitionEndHandler : undefined}\n                  ref={(el) => panelId !== undefined && (this.panelNodes[panelId] = el)}\n                  style={this.calcPanelSwipeStyles(panelId)}\n                  key={panelId}\n                >\n                  <div\n                    className={styles['View__panel-in']}\n                    style={{ marginTop: compensateScroll ? -scroll : undefined }}\n                  >\n                    <NavTransitionDirectionProvider isBack={swipingBack || isBack}>\n                      <NavTransitionProvider\n                        entering={panelId === nextPanel || panelId === swipeBackNextPanel}\n                      >\n                        {panel}\n                      </NavTransitionProvider>\n                    </NavTransitionDirectionProvider>\n                  </div>\n                </div>\n              );\n            })}\n          </div>\n        </Touch>\n      </NavViewIdContext.Provider>\n    );\n  }\n}\n\nexport const ViewInfinite = withContext(\n  withContext(\n    withContext(\n      withPlatform(withDOM<ViewInfiniteProps>(ViewInfiniteComponent)),\n      SplitColContext,\n      'splitCol',\n    ),\n    ConfigProviderContext,\n    'configProvider',\n  ),\n  ScrollContext,\n  'scroll',\n);\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}