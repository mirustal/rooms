{"ast":null,"code":"import { _ as _to_consumable_array } from \"@swc/helpers/_/_to_consumable_array\";\nimport { SLIDE_THRESHOLD } from \"./constants\";\n/*\n * Считает отступ слоя галереи\n */\nexport function calculateIndent(targetIndex, slidesManager, isCenterWithCustomWidth) {\n  if (slidesManager.isFullyVisible || !slidesManager.slides.length) {\n    return 0;\n  }\n  var targetSlide = slidesManager.slides[targetIndex];\n  if (targetSlide) {\n    var coordX = targetSlide.coordX,\n      width = targetSlide.width;\n    if (isCenterWithCustomWidth) {\n      return slidesManager.viewportOffsetWidth / 2 - coordX - width / 2;\n    }\n    return -1 * coordX;\n  }\n  return 0;\n}\n/**\n * Вычисляем индексы слайдов, которые необходимо смещать\n */\nexport function getShiftedIndexes(direction, slides, availableWidth) {\n  var gap = availableWidth;\n  var shiftedSlideIndexes = [];\n  var startIndex = direction === 1 ? 0 : slides.length - 1;\n  var endIndex = direction === 1 ? slides.length - 1 : 0;\n  for (var i = startIndex; (direction === 1 ? i <= endIndex : i >= endIndex) && gap > 0; i += direction) {\n    var slideWidth = slides[i].width;\n    if (gap > 0) {\n      shiftedSlideIndexes.push(i);\n    }\n    gap -= slideWidth;\n  }\n  return shiftedSlideIndexes;\n}\nexport function calculateLoopPoints(indexes, edge, slidesManager, containerWidth) {\n  var contentSize = slidesManager.contentSize,\n    slides = slidesManager.slides,\n    snaps = slidesManager.snaps;\n  var isStartEdge = edge === \"start\";\n  var offset = isStartEdge ? -contentSize : contentSize;\n  return indexes.map(function (index) {\n    var initial = isStartEdge ? 0 : -contentSize;\n    var altered = isStartEdge ? contentSize : 0;\n    var loopPoint = isStartEdge ? snaps[index] + containerWidth + offset : snaps[index] - slides[index].width + offset - snaps[0];\n    return {\n      index: index,\n      target: function (currentLocation) {\n        return currentLocation >= loopPoint ? initial : altered;\n      }\n    };\n  });\n}\n/**\n * Вычисляем \"ключевые\" точки, на которых должно происходить смещение слайдов\n */\nexport function getLoopPoints(slidesManager, containerWidth) {\n  var slides = slidesManager.slides,\n    snaps = slidesManager.snaps;\n  var startShiftedIndexes = getShiftedIndexes(-1, slides, snaps[0]);\n  var endShiftedIndexes = getShiftedIndexes(1, slides, containerWidth - snaps[0]);\n  return _to_consumable_array(calculateLoopPoints(endShiftedIndexes, \"start\", slidesManager, containerWidth)).concat(_to_consumable_array(calculateLoopPoints(startShiftedIndexes, \"end\", slidesManager, containerWidth)));\n}\n/*\n * Получает индекс слайда, к которому будет осуществлен переход\n */\nexport function getTargetIndex(slides, slideIndex, currentShiftX, currentShiftXDelta) {\n  var shift = currentShiftX + currentShiftXDelta;\n  var direction = currentShiftXDelta < 0 ? 1 : -1;\n  // Находим ближайшую границу слайда к текущему отступу\n  var targetIndex = slides.reduce(function (val, item, index) {\n    var previousValue = Math.abs(slides[val].coordX + shift);\n    var currentValue = Math.abs(item.coordX + shift);\n    return previousValue < currentValue ? val : index;\n  }, slideIndex);\n  if (targetIndex === slideIndex) {\n    var targetSlide = slideIndex + direction;\n    if (targetSlide >= 0 && targetSlide < slides.length) {\n      if (Math.abs(currentShiftXDelta) > slides[targetSlide].width * SLIDE_THRESHOLD) {\n        return targetSlide;\n      }\n      return targetIndex;\n    }\n    return direction < 0 ? (targetSlide + slides.length) % slides.length : targetSlide % slides.length;\n  }\n  return targetIndex;\n}","map":{"version":3,"names":["SLIDE_THRESHOLD","calculateIndent","targetIndex","slidesManager","isCenterWithCustomWidth","isFullyVisible","slides","length","targetSlide","coordX","width","viewportOffsetWidth","getShiftedIndexes","direction","availableWidth","gap","shiftedSlideIndexes","startIndex","endIndex","i","slideWidth","push","calculateLoopPoints","indexes","edge","containerWidth","contentSize","snaps","isStartEdge","offset","map","index","initial","altered","loopPoint","target","currentLocation","getLoopPoints","startShiftedIndexes","endShiftedIndexes","_to_consumable_array","concat","getTargetIndex","slideIndex","currentShiftX","currentShiftXDelta","shift","reduce","val","item","previousValue","Math","abs","currentValue"],"sources":["../../../../src/components/BaseGallery/CarouselBase/helpers.ts"],"sourcesContent":["import { GallerySlidesState } from '../types';\nimport { SLIDE_THRESHOLD } from './constants';\nimport { LoopPoint, SlidesManagerState } from './types';\n\n/*\n * Считает отступ слоя галереи\n */\nexport function calculateIndent(\n  targetIndex: number,\n  slidesManager: SlidesManagerState,\n  isCenterWithCustomWidth: boolean,\n) {\n  if (slidesManager.isFullyVisible || !slidesManager.slides.length) {\n    return 0;\n  }\n\n  const targetSlide = slidesManager.slides[targetIndex];\n\n  if (targetSlide) {\n    const { coordX, width } = targetSlide;\n\n    if (isCenterWithCustomWidth) {\n      return slidesManager.viewportOffsetWidth / 2 - coordX - width / 2;\n    }\n\n    return -1 * coordX;\n  }\n\n  return 0;\n}\n\n/**\n * Вычисляем индексы слайдов, которые необходимо смещать\n */\nexport function getShiftedIndexes(\n  direction: 1 | -1,\n  slides: GallerySlidesState[],\n  availableWidth: number,\n) {\n  let gap = availableWidth;\n  const shiftedSlideIndexes = [];\n  const startIndex = direction === 1 ? 0 : slides.length - 1;\n  const endIndex = direction === 1 ? slides.length - 1 : 0;\n\n  for (\n    let i = startIndex;\n    (direction === 1 ? i <= endIndex : i >= endIndex) && gap > 0;\n    i += direction\n  ) {\n    const slideWidth = slides[i].width;\n\n    if (gap > 0) {\n      shiftedSlideIndexes.push(i);\n    }\n    gap -= slideWidth;\n  }\n\n  return shiftedSlideIndexes;\n}\n\nexport function calculateLoopPoints(\n  indexes: number[],\n  edge: 'start' | 'end',\n  slidesManager: SlidesManagerState,\n  containerWidth: number,\n): LoopPoint[] {\n  const { contentSize, slides, snaps } = slidesManager;\n  const isStartEdge = edge === 'start';\n  const offset = isStartEdge ? -contentSize : contentSize;\n\n  return indexes.map((index) => {\n    const initial = isStartEdge ? 0 : -contentSize;\n    const altered = isStartEdge ? contentSize : 0;\n    const loopPoint = isStartEdge\n      ? snaps[index] + containerWidth + offset\n      : snaps[index] - slides[index].width + offset - snaps[0];\n\n    return {\n      index,\n      target: (currentLocation) => {\n        return currentLocation >= loopPoint ? initial : altered;\n      },\n    };\n  });\n}\n\n/**\n * Вычисляем \"ключевые\" точки, на которых должно происходить смещение слайдов\n */\nexport function getLoopPoints(slidesManager: SlidesManagerState, containerWidth: number) {\n  const { slides, snaps } = slidesManager;\n  const startShiftedIndexes = getShiftedIndexes(-1, slides, snaps[0]);\n  const endShiftedIndexes = getShiftedIndexes(1, slides, containerWidth - snaps[0]);\n\n  return [\n    ...calculateLoopPoints(endShiftedIndexes, 'start', slidesManager, containerWidth),\n    ...calculateLoopPoints(startShiftedIndexes, 'end', slidesManager, containerWidth),\n  ];\n}\n\n/*\n * Получает индекс слайда, к которому будет осуществлен переход\n */\nexport function getTargetIndex(\n  slides: GallerySlidesState[],\n  slideIndex: number,\n  currentShiftX: number,\n  currentShiftXDelta: number,\n) {\n  const shift = currentShiftX + currentShiftXDelta;\n  const direction = currentShiftXDelta < 0 ? 1 : -1;\n\n  // Находим ближайшую границу слайда к текущему отступу\n  let targetIndex = slides.reduce((val: number, item: GallerySlidesState, index: number) => {\n    const previousValue = Math.abs(slides[val].coordX + shift);\n    const currentValue = Math.abs(item.coordX + shift);\n\n    return previousValue < currentValue ? val : index;\n  }, slideIndex);\n\n  if (targetIndex === slideIndex) {\n    let targetSlide = slideIndex + direction;\n\n    if (targetSlide >= 0 && targetSlide < slides.length) {\n      if (Math.abs(currentShiftXDelta) > slides[targetSlide].width * SLIDE_THRESHOLD) {\n        return targetSlide;\n      }\n      return targetIndex;\n    }\n    return direction < 0\n      ? (targetSlide + slides.length) % slides.length\n      : targetSlide % slides.length;\n  }\n\n  return targetIndex;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}