{"ast":null,"code":"import { _ as _sliced_to_array } from \"@swc/helpers/_/_sliced_to_array\";\nimport * as React from \"react\";\nimport { getMillisecondsToTomorrow, isSameDay } from \"../lib/date\";\nimport { useDOM } from \"../lib/dom\";\n/**\n * Опционально обновляемая дата сегодняшнего дня\n *\n * Дата - сегодня (в соответствии с системным временем)\n *\n * Часы, минуты, секунды, миллисекунды - произвольные\n *\n * @param listenDayChangesForUpdate - флаг по которому определяется, будет ли создаваться подписка на смену календарного дня\n */\nexport function useTodayDate() {\n  var listenDayChangesForUpdate = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;\n  var _useDOM = useDOM(),\n    document = _useDOM.document,\n    window = _useDOM.window;\n  var _React_useState = _sliced_to_array(React.useState(function () {\n      return new Date();\n    }), 2),\n    todayDate = _React_useState[0],\n    setTodayDate = _React_useState[1];\n  React.useEffect(function () {\n    if (!listenDayChangesForUpdate || !document || !window) {\n      return;\n    }\n    var timeout = undefined;\n    var recalcTimeout = function () {\n      if (document.visibilityState === \"visible\") {\n        var now = new Date();\n        var timeToDayChange = getMillisecondsToTomorrow(now);\n        // Удаляем старый таймаут\n        window.clearTimeout(timeout);\n        // Создаем новый таймаут\n        timeout = window.setTimeout(function () {\n          setTodayDate(now);\n        }, timeToDayChange);\n        // Если todayDate не обновился в таймаут - обновить при заходе на вкладку\n        if (!isSameDay(todayDate, now)) {\n          setTodayDate(now);\n        }\n      }\n    };\n    recalcTimeout();\n    // Создаем слушатель visibilitychange, чтобы предотвратить пропуск обновления стейта после заморозки вкладки\n    // Если человек ее долго не трогал или закрывал крышку ноута и тп\n    // https://developer.chrome.com/blog/page-lifecycle-api/\n    document.addEventListener(\"visibilitychange\", recalcTimeout);\n    return function () {\n      window.clearTimeout(timeout);\n      document.removeEventListener(\"visibilitychange\", recalcTimeout);\n    };\n  }, [document, listenDayChangesForUpdate, todayDate, window]);\n  return todayDate;\n}","map":{"version":3,"names":["React","getMillisecondsToTomorrow","isSameDay","useDOM","useTodayDate","listenDayChangesForUpdate","arguments","length","_useDOM","document","window","_React_useState","_sliced_to_array","useState","Date","todayDate","setTodayDate","useEffect","timeout","undefined","recalcTimeout","visibilityState","now","timeToDayChange","clearTimeout","setTimeout","addEventListener","removeEventListener"],"sources":["../../src/hooks/useTodayDate.ts"],"sourcesContent":["import * as React from 'react';\nimport { getMillisecondsToTomorrow, isSameDay } from '../lib/date';\nimport { useDOM } from '../lib/dom';\n\n/**\n * Опционально обновляемая дата сегодняшнего дня\n *\n * Дата - сегодня (в соответствии с системным временем)\n *\n * Часы, минуты, секунды, миллисекунды - произвольные\n *\n * @param listenDayChangesForUpdate - флаг по которому определяется, будет ли создаваться подписка на смену календарного дня\n */\nexport function useTodayDate(listenDayChangesForUpdate = false) {\n  const { document, window } = useDOM();\n  const [todayDate, setTodayDate] = React.useState(() => new Date());\n\n  React.useEffect(() => {\n    if (!listenDayChangesForUpdate || !document || !window) {\n      return;\n    }\n\n    let timeout: number | undefined = undefined;\n\n    const recalcTimeout = () => {\n      if (document.visibilityState === 'visible') {\n        const now = new Date();\n\n        const timeToDayChange = getMillisecondsToTomorrow(now);\n\n        // Удаляем старый таймаут\n        window.clearTimeout(timeout);\n\n        // Создаем новый таймаут\n        timeout = window.setTimeout(() => {\n          setTodayDate(now);\n        }, timeToDayChange);\n\n        // Если todayDate не обновился в таймаут - обновить при заходе на вкладку\n        if (!isSameDay(todayDate, now)) {\n          setTodayDate(now);\n        }\n      }\n    };\n\n    recalcTimeout();\n\n    // Создаем слушатель visibilitychange, чтобы предотвратить пропуск обновления стейта после заморозки вкладки\n    // Если человек ее долго не трогал или закрывал крышку ноута и тп\n    // https://developer.chrome.com/blog/page-lifecycle-api/\n    document.addEventListener('visibilitychange', recalcTimeout);\n\n    return () => {\n      window.clearTimeout(timeout);\n      document.removeEventListener('visibilitychange', recalcTimeout);\n    };\n  }, [document, listenDayChangesForUpdate, todayDate, window]);\n\n  return todayDate;\n}\n"],"mappings":";AAAA,YAAYA,KAAA,MAAW;AACvB,SAASC,yBAAyB,EAAEC,SAAS,QAAQ;AACrD,SAASC,MAAM,QAAQ;AAEvB;;;;;;;;;AASA,OAAO,SAASC,aAAA;MAAaC,yBAAA,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,iBAAAA,SAAA,MAA4B;EACvD,IAA6BE,OAAA,GAAAL,MAAA;IAArBM,QAAA,GAAqBD,OAAA,CAArBC,QAAA;IAAUC,MAAA,GAAWF,OAAA,CAAXE,MAAA;EAClB,IAAkCC,eAAA,GAAAC,gBAAA,CAAAZ,KAAA,CAAMa,QAAQ,CAAC;aAAM,IAAIC,IAAA;;IAApDC,SAAA,GAA2BJ,eAAA;IAAhBK,YAAA,GAAgBL,eAAA;EAElCX,KAAA,CAAMiB,SAAS,CAAC;IACd,IAAI,CAACZ,yBAAA,IAA6B,CAACI,QAAA,IAAY,CAACC,MAAA,EAAQ;MACtD;IACF;IAEA,IAAIQ,OAAA,GAA8BC,SAAA;IAElC,IAAMC,aAAA,GAAgB,SAAAA,CAAA;MACpB,IAAIX,QAAA,CAASY,eAAe,KAAK,WAAW;QAC1C,IAAMC,GAAA,GAAM,IAAIR,IAAA;QAEhB,IAAMS,eAAA,GAAkBtB,yBAAA,CAA0BqB,GAAA;QAElD;QACAZ,MAAA,CAAOc,YAAY,CAACN,OAAA;QAEpB;QACAA,OAAA,GAAUR,MAAA,CAAOe,UAAU,CAAC;UAC1BT,YAAA,CAAaM,GAAA;QACf,GAAGC,eAAA;QAEH;QACA,IAAI,CAACrB,SAAA,CAAUa,SAAA,EAAWO,GAAA,GAAM;UAC9BN,YAAA,CAAaM,GAAA;QACf;MACF;IACF;IAEAF,aAAA;IAEA;IACA;IACA;IACAX,QAAA,CAASiB,gBAAgB,CAAC,oBAAoBN,aAAA;IAE9C,OAAO;MACLV,MAAA,CAAOc,YAAY,CAACN,OAAA;MACpBT,QAAA,CAASkB,mBAAmB,CAAC,oBAAoBP,aAAA;IACnD;EACF,GAAG,CAACX,QAAA,EAAUJ,yBAAA,EAA2BU,SAAA,EAAWL,MAAA,CAAO;EAE3D,OAAOK,SAAA;AACT"},"metadata":{},"sourceType":"module"}