{"ast":null,"code":"import { _ as _object_spread } from \"@swc/helpers/_/_object_spread\";\nimport { _ as _object_spread_props } from \"@swc/helpers/_/_object_spread_props\";\nimport { _ as _object_without_properties } from \"@swc/helpers/_/_object_without_properties\";\nimport { _ as _sliced_to_array } from \"@swc/helpers/_/_sliced_to_array\";\nimport * as React from \"react\";\nimport { classNames, noop } from \"@vkontakte/vkjs\";\nimport { usePlatform } from \"../../hooks/usePlatform\";\nimport { usePrevious } from \"../../hooks/usePrevious\";\nimport { useTimeout } from \"../../hooks/useTimeout\";\nimport { useWaitTransitionFinish } from \"../../hooks/useWaitTransitionFinish\";\nimport { blurActiveElement, canUseDOM, useDOM } from \"../../lib/dom\";\nimport { getNavId } from \"../../lib/getNavId\";\nimport { Platform } from \"../../lib/platform\";\nimport { animationEvent } from \"../../lib/supportEvents\";\nimport { useIsomorphicLayoutEffect } from \"../../lib/useIsomorphicLayoutEffect\";\nimport { warnOnce } from \"../../lib/warnOnce\";\nimport { useScroll } from \"../AppRoot/ScrollContext\";\nimport { useConfigProvider } from \"../ConfigProvider/ConfigProviderContext\";\nimport { NavViewIdContext } from \"../NavIdContext/NavIdContext\";\nimport { NavTransitionProvider } from \"../NavTransitionContext/NavTransitionContext\";\nimport { NavTransitionDirectionProvider } from \"../NavTransitionDirectionContext/NavTransitionDirectionContext\";\nimport { useSplitCol } from \"../SplitCol/SplitColContext\";\nimport { Touch } from \"../Touch/Touch\";\nimport { getSwipeBackPredicates, hasHorizontalScrollableElementWithScrolledToLeft, swipeBackExcluded } from \"./utils\";\nvar SwipeBackResults;\n(function (SwipeBackResults) {\n  SwipeBackResults[SwipeBackResults[\"fail\"] = 1] = \"fail\";\n  SwipeBackResults[SwipeBackResults[\"success\"] = 2] = \"success\";\n})(SwipeBackResults || (SwipeBackResults = {}));\nexport var scrollsCache = {};\nvar warn = warnOnce(\"View\");\n/**\n * @see https://vkcom.github.io/VKUI/#/View\n */\nexport var View = function (_param) {\n  var activePanelProp = _param.activePanel,\n    history = _param.history,\n    nav = _param.nav,\n    onTransition = _param.onTransition,\n    onSwipeBack = _param.onSwipeBack,\n    onSwipeBackStart = _param.onSwipeBackStart,\n    onSwipeBackCancelProp = _param.onSwipeBackCancel,\n    children = _param.children,\n    className = _param.className,\n    restProps = _object_without_properties(_param, [\"activePanel\", \"history\", \"nav\", \"onTransition\", \"onSwipeBack\", \"onSwipeBackStart\", \"onSwipeBackCancel\", \"children\", \"className\"]);\n  var id = getNavId({\n    nav: nav,\n    id: restProps.id\n  });\n  var scrolls = React.useRef(scrollsCache[id] || {});\n  var afterTransition = React.useRef(noop);\n  React.useEffect(function () {\n    return function () {\n      if (id) {\n        scrollsCache[id] = scrolls.current;\n      }\n    };\n  });\n  var panelNodes = React.useRef({});\n  var _useDOM = useDOM(),\n    window = _useDOM.window,\n    document = _useDOM.document;\n  var scroll = useScroll();\n  var configProvider = useConfigProvider();\n  var splitCol = useSplitCol();\n  var platform = usePlatform();\n  var _React_useState = _sliced_to_array(React.useState(false), 2),\n    animated = _React_useState[0],\n    setAnimated = _React_useState[1];\n  var _React_useState1 = _sliced_to_array(React.useState([activePanelProp]), 2),\n    visiblePanels = _React_useState1[0],\n    setVisiblePanels = _React_useState1[1];\n  var _React_useState2 = _sliced_to_array(React.useState(activePanelProp), 2),\n    activePanel = _React_useState2[0],\n    setActivePanel = _React_useState2[1];\n  var _React_useState3 = _sliced_to_array(React.useState(undefined), 2),\n    isBack = _React_useState3[0],\n    setIsBack = _React_useState3[1];\n  var _React_useState4 = _sliced_to_array(React.useState(null), 2),\n    prevPanel = _React_useState4[0],\n    setPrevPanel = _React_useState4[1];\n  var _React_useState5 = _sliced_to_array(React.useState(null), 2),\n    nextPanel = _React_useState5[0],\n    setNextPanel = _React_useState5[1];\n  var swipeBackPrevented = React.useRef(false);\n  var _React_useState6 = _sliced_to_array(React.useState(undefined), 2),\n    swipingBack = _React_useState6[0],\n    setSwipingBack = _React_useState6[1];\n  var _React_useState7 = _sliced_to_array(React.useState(0), 2),\n    swipeBackStartX = _React_useState7[0],\n    setSwipeBackStartX = _React_useState7[1];\n  var _React_useState8 = _sliced_to_array(React.useState(0), 2),\n    swipeBackShift = _React_useState8[0],\n    setSwipeBackShift = _React_useState8[1];\n  var _React_useState9 = _sliced_to_array(React.useState(null), 2),\n    swipeBackNextPanel = _React_useState9[0],\n    setSwipeBackNextPanel = _React_useState9[1];\n  var _React_useState10 = _sliced_to_array(React.useState(null), 2),\n    swipeBackPrevPanel = _React_useState10[0],\n    setSwipeBackPrevPanel = _React_useState10[1];\n  var _React_useState11 = _sliced_to_array(React.useState(null), 2),\n    swipeBackResult = _React_useState11[0],\n    setSwipeBackResult = _React_useState11[1];\n  var _React_useState12 = _sliced_to_array(React.useState(false), 2),\n    browserSwipe = _React_useState12[0],\n    setBrowserSwipe = _React_useState12[1];\n  var prevActivePanel = usePrevious(activePanelProp);\n  var prevSwipingBack = usePrevious(swipingBack);\n  var prevBrowserSwipe = usePrevious(browserSwipe);\n  var prevSwipeBackResult = usePrevious(swipeBackResult);\n  var prevSwipeBackPrevPanel = usePrevious(swipeBackPrevPanel);\n  var prevOnTransition = usePrevious(onTransition);\n  var panels = React.Children.toArray(children).filter(function (panel) {\n    var panelId = getNavId(panel.props, warn);\n    return panelId !== undefined && visiblePanels.includes(panelId) || panelId === swipeBackPrevPanel || panelId === swipeBackNextPanel;\n  });\n  var disableAnimation = !configProvider.transitionMotionEnabled || !splitCol.animate || platform === Platform.VKCOM;\n  var iOSSwipeBackSimulationEnabled = !disableAnimation && platform === Platform.IOS && configProvider.isWebView && Boolean(onSwipeBack);\n  var pickPanel = function (id) {\n    if (id === null) {\n      return null;\n    }\n    return panelNodes.current[id];\n  };\n  var flushTransition = React.useCallback(function (prevPanel, isBackTransition) {\n    if (isBackTransition) {\n      scrolls.current[prevPanel] = 0;\n    }\n    setPrevPanel(null);\n    setNextPanel(null);\n    setVisiblePanels([activePanelProp]);\n    setActivePanel(activePanelProp);\n    setAnimated(false);\n    setIsBack(isBackTransition);\n    afterTransition.current = function () {\n      scroll === null || scroll === void 0 ? void 0 : scroll.scrollTo(0, isBackTransition ? scrolls.current[activePanelProp] : 0);\n      onTransition && onTransition({\n        isBack: isBackTransition,\n        from: prevPanel,\n        to: activePanelProp\n      });\n    };\n  }, [activePanelProp, onTransition, scroll]);\n  useIsomorphicLayoutEffect(function () {\n    afterTransition.current();\n    afterTransition.current = noop;\n  }, [afterTransition.current]);\n  var transitionEndHandler = React.useCallback(function (e) {\n    if ((!e || [\"vkuianimation-ios-next-forward\", \"vkuianimation-ios-prev-back\", \"vkuianimation-view-next-forward\", \"vkuianimation-view-prev-back\"].includes(e.animationName)) && prevPanel !== null) {\n      flushTransition(prevPanel, Boolean(isBack));\n    }\n  }, [flushTransition, isBack, prevPanel]);\n  var waitTransitionFinish = useWaitTransitionFinish().waitTransitionFinish;\n  var animationFinishTimeout = useTimeout(transitionEndHandler, platform === Platform.IOS ? 600 : 300);\n  var onSwipeBackSuccess = React.useCallback(function () {\n    onSwipeBack && onSwipeBack();\n  }, [onSwipeBack]);\n  var onSwipeBackCancel = React.useCallback(function () {\n    onSwipeBackCancelProp && onSwipeBackCancelProp();\n    setSwipeBackPrevPanel(null);\n    setSwipeBackNextPanel(null);\n    setSwipingBack(false);\n    setSwipeBackResult(null);\n    setSwipeBackStartX(0);\n    setSwipeBackShift(0);\n  }, [onSwipeBackCancelProp]);\n  var swipingBackTransitionEndHandler = React.useCallback(function (e) {\n    // indexOf because of vendor prefixes in old browsers\n    if (!e || (e === null || e === void 0 ? void 0 : e.propertyName.includes(\"transform\")) && (e === null || e === void 0 ? void 0 : e.target) === pickPanel(swipeBackNextPanel)) {\n      switch (swipeBackResult) {\n        case 1:\n          onSwipeBackCancel();\n          break;\n        case 2:\n          onSwipeBackSuccess();\n      }\n    }\n  }, [onSwipeBackCancel, onSwipeBackSuccess, swipeBackNextPanel, swipeBackResult]);\n  var handleTouchMoveXForNativeIOSSwipeBackOrSwipeNext = function (event) {\n    if (browserSwipe) {\n      return;\n    }\n    var _getSwipeBackPredicates = getSwipeBackPredicates(event.startX, event.shiftX, window.innerWidth),\n      swipeBackTriggered = _getSwipeBackPredicates.swipeBackTriggered,\n      viewportStartEdgeTouched = _getSwipeBackPredicates.viewportStartEdgeTouched,\n      viewportEndEdgeTouched = _getSwipeBackPredicates.viewportEndEdgeTouched;\n    if ((viewportStartEdgeTouched || viewportEndEdgeTouched) && swipeBackTriggered) {\n      setBrowserSwipe(true);\n    }\n  };\n  var handleTouchMoveXForIOSSwipeBackSimulation = function (event) {\n    if (swipeBackPrevented.current || swipeBackExcluded(event)) {\n      return;\n    }\n    var _getSwipeBackPredicates = getSwipeBackPredicates(event.startX, event.shiftX, window.innerWidth),\n      swipedToOpposite = _getSwipeBackPredicates.swipedToOpposite,\n      swipeBackTriggered = _getSwipeBackPredicates.swipeBackTriggered,\n      viewportStartEdgeTouched = _getSwipeBackPredicates.viewportStartEdgeTouched;\n    if (animated && swipeBackTriggered) {\n      return;\n    }\n    if (!swipingBack && history && history.length > 1) {\n      if (swipedToOpposite) {\n        swipeBackPrevented.current = true;\n        return;\n      }\n      if (!swipeBackTriggered) {\n        return;\n      }\n      if (!viewportStartEdgeTouched && hasHorizontalScrollableElementWithScrolledToLeft(event.originalEvent.target)) {\n        swipeBackPrevented.current = true;\n        return;\n      }\n      // Начался свайп назад\n      if (onSwipeBackStart) {\n        var payload = onSwipeBackStart(activePanel);\n        if (payload === \"prevent\") {\n          swipeBackPrevented.current = true;\n          return;\n        }\n      }\n      if (activePanel !== null) {\n        // Note: вызываем закрытие клавиатуры. В iOS это нативное поведение при свайпе.\n        blurActiveElement(document);\n        scrolls.current[activePanel] = scroll === null || scroll === void 0 ? void 0 : scroll.getScroll().y;\n      }\n      setSwipingBack(true);\n      setSwipeBackStartX(event.startX);\n      setSwipeBackPrevPanel(activePanel);\n      setSwipeBackNextPanel(history.slice(-2)[0]);\n    }\n    if (swipingBack) {\n      if (event.shiftX < 0) {\n        setSwipeBackShift(0);\n      } else if (event.shiftX > window.innerWidth - swipeBackStartX) {\n        setSwipeBackShift(window.innerWidth);\n      } else {\n        setSwipeBackShift(event.shiftX);\n      }\n    }\n  };\n  var handleTouchEndForIOSSwipeBackSimulation = function (event) {\n    swipeBackPrevented.current = false;\n    if (swipingBack) {\n      var speed = swipeBackShift / event.duration * 1000;\n      var _window_innerWidth;\n      if (swipeBackShift === 0) {\n        onSwipeBackCancel();\n      } else if (swipeBackShift >= ((_window_innerWidth = window.innerWidth) !== null && _window_innerWidth !== void 0 ? _window_innerWidth : 0)) {\n        onSwipeBackSuccess();\n      } else if (speed > 250 || swipeBackShift >= window.innerWidth / 2) {\n        setSwipeBackResult(2);\n      } else {\n        setSwipeBackResult(1);\n      }\n    }\n  };\n  var calcPanelSwipeStyles = function (panelId) {\n    if (!canUseDOM || !window) {\n      return {};\n    }\n    var isPrev = panelId === swipeBackPrevPanel;\n    var isNext = panelId === swipeBackNextPanel;\n    if (!isPrev && !isNext || swipeBackResult) {\n      return {};\n    }\n    var prevPanelTranslate = \"\".concat(swipeBackShift, \"px\");\n    var nextPanelTranslate = \"\".concat(-50 + swipeBackShift * 100 / window.innerWidth / 2, \"%\");\n    if (isNext) {\n      return {\n        transform: \"translate3d(\".concat(nextPanelTranslate, \", 0, 0)\"),\n        WebkitTransform: \"translate3d(\".concat(nextPanelTranslate, \", 0, 0)\")\n      };\n    }\n    if (isPrev) {\n      return {\n        transform: \"translate3d(\".concat(prevPanelTranslate, \", 0, 0)\"),\n        WebkitTransform: \"translate3d(\".concat(prevPanelTranslate, \", 0, 0)\")\n      };\n    }\n    return {};\n  };\n  var calcPanelSwipeBackOverlayStyles = function (panelId) {\n    if (!canUseDOM || !window) {\n      return {};\n    }\n    var isNext = panelId === swipeBackNextPanel;\n    if (!isNext) {\n      return {};\n    }\n    var calculatedOpacity = 1 - swipeBackShift / window.innerWidth;\n    var opacityOnSwipeEnd = swipeBackResult === 2 ? 0 : swipeBackResult === 1 ? 1 : null;\n    return {\n      display: \"block\",\n      opacity: opacityOnSwipeEnd === null ? calculatedOpacity : opacityOnSwipeEnd\n    };\n  };\n  React.useEffect(function () {\n    // Нужен переход\n    if (prevActivePanel && prevActivePanel !== activePanelProp && !prevSwipingBack && !prevBrowserSwipe) {\n      var firstLayerId = React.Children.toArray(children).map(function (panel) {\n        return getNavId(panel.props, warn);\n      }).find(function (id) {\n        return id === prevActivePanel || id === activePanelProp;\n      });\n      var isBackTransition = firstLayerId === activePanelProp;\n      scrolls.current[prevActivePanel] = scroll === null || scroll === void 0 ? void 0 : scroll.getScroll().y;\n      if (disableAnimation) {\n        flushTransition(prevActivePanel, isBackTransition);\n      } else {\n        blurActiveElement(document);\n        setVisiblePanels([prevActivePanel, activePanelProp]);\n        setPrevPanel(prevActivePanel);\n        setNextPanel(activePanelProp);\n        setActivePanel(null);\n        setAnimated(true);\n        setIsBack(isBackTransition);\n        // Фолбек анимации перехода\n        if (!animationEvent.supported) {\n          animationFinishTimeout.set();\n        }\n      }\n    }\n    // Закончилась анимация свайпа назад\n    if (prevActivePanel && prevActivePanel !== activePanelProp && prevSwipingBack) {\n      var nextPanel = activePanelProp;\n      var prevPanel = prevActivePanel;\n      if (prevSwipeBackPrevPanel) {\n        scrolls.current[prevSwipeBackPrevPanel] = 0;\n      }\n      setSwipeBackPrevPanel(null);\n      setSwipeBackNextPanel(null);\n      setSwipingBack(false);\n      setSwipeBackResult(null);\n      setSwipeBackStartX(0);\n      setSwipeBackShift(0);\n      setActivePanel(nextPanel);\n      setVisiblePanels([nextPanel]);\n      setIsBack(true);\n      afterTransition.current = function () {\n        if (nextPanel !== null) {\n          scroll === null || scroll === void 0 ? void 0 : scroll.scrollTo(0, scrolls.current[nextPanel]);\n        }\n        prevOnTransition && prevOnTransition({\n          isBack: true,\n          from: prevPanel,\n          to: nextPanel\n        });\n      };\n    }\n    // Началась анимация завершения свайпа назад.\n    if (!prevSwipeBackResult && swipeBackResult) {\n      waitTransitionFinish(pickPanel(swipeBackNextPanel), swipingBackTransitionEndHandler, platform === Platform.IOS ? 600 : 300);\n    }\n    // Если свайп назад отменился (когда пользователь недостаточно сильно свайпнул)\n    if (prevSwipeBackResult === 1 && !swipeBackResult && activePanel !== null) {\n      scroll === null || scroll === void 0 ? void 0 : scroll.scrollTo(0, scrolls.current[activePanel]);\n    }\n    // Закончился Safari свайп\n    if (prevActivePanel !== activePanelProp && browserSwipe) {\n      setBrowserSwipe(false);\n      setNextPanel(null);\n      setPrevPanel(null);\n      setAnimated(false);\n      setVisiblePanels([activePanelProp]);\n      setActivePanel(activePanelProp);\n    }\n  }, [activePanelProp, activePanel, animationFinishTimeout, browserSwipe, children, disableAnimation, document, flushTransition, platform, prevActivePanel, prevBrowserSwipe, prevOnTransition, prevSwipeBackPrevPanel, prevSwipeBackResult, prevSwipingBack, scroll, swipeBackNextPanel, swipeBackResult, swipingBackTransitionEndHandler, waitTransitionFinish]);\n  return /*#__PURE__*/React.createElement(NavViewIdContext.Provider, {\n    value: id\n  }, /*#__PURE__*/React.createElement(Touch, _object_spread_props(_object_spread({\n    Component: \"section\"\n  }, restProps), {\n    className: classNames(\"vkuiView\", platform === Platform.IOS && classNames(\"vkuiView--ios\", \"vkuiInternalView--ios\"), !disableAnimation && animated && \"vkuiView--animated\", !disableAnimation && swipingBack && \"vkuiView--swiping-back\", disableAnimation && \"vkuiView--no-motion\", className),\n    onMoveX: iOSSwipeBackSimulationEnabled ? handleTouchMoveXForIOSSwipeBackSimulation : platform === Platform.IOS ? handleTouchMoveXForNativeIOSSwipeBackOrSwipeNext : undefined,\n    onEnd: iOSSwipeBackSimulationEnabled ? handleTouchEndForIOSSwipeBackSimulation : undefined\n  }), /*#__PURE__*/React.createElement(\"div\", {\n    className: \"vkuiView__panels\"\n  }, panels.map(function (panel) {\n    var panelId = getNavId(panel.props, warn);\n    var isPrev = panelId === prevPanel || panelId === swipeBackPrevPanel;\n    var isTransitionTarget = animated && panelId === (isBack ? prevPanel : nextPanel);\n    var compensateScroll = isPrev || panelId === swipeBackNextPanel || panelId === nextPanel && isBack;\n    var _scrolls_current_panelId;\n    return /*#__PURE__*/React.createElement(\"div\", {\n      className: classNames(\"vkuiView__panel\", panelId === activePanel && \"vkuiView__panel--active\", panelId === prevPanel && \"vkuiView__panel--prev\", panelId === nextPanel && \"vkuiView__panel--next\", panelId === swipeBackPrevPanel && \"vkuiView__panel--swipe-back-prev\", panelId === swipeBackNextPanel && \"vkuiView__panel--swipe-back-next\", swipeBackResult === 2 && \"vkuiView__panel--swipe-back-success\", swipeBackResult === 1 && \"vkuiView__panel--swipe-back-failed\"),\n      onAnimationEnd: isTransitionTarget ? transitionEndHandler : undefined,\n      ref: function (el) {\n        return panelId !== undefined && (panelNodes.current[panelId] = el);\n      },\n      style: calcPanelSwipeStyles(panelId),\n      key: panelId\n    }, platform === Platform.IOS && /*#__PURE__*/React.createElement(\"div\", {\n      className: \"vkuiView__panel-overlay\",\n      style: calcPanelSwipeBackOverlayStyles(panelId)\n    }), /*#__PURE__*/React.createElement(\"div\", {\n      className: \"vkuiView__panel-in\",\n      style: {\n        marginTop: compensateScroll ? -((_scrolls_current_panelId = scrolls.current[panelId]) !== null && _scrolls_current_panelId !== void 0 ? _scrolls_current_panelId : 0) : undefined\n      }\n    }, /*#__PURE__*/React.createElement(NavTransitionDirectionProvider, {\n      isBack: swipingBack || isBack\n    }, /*#__PURE__*/React.createElement(NavTransitionProvider, {\n      entering: panelId === nextPanel || panelId === swipeBackNextPanel\n    }, panel))));\n  }))));\n};","map":{"version":3,"names":["React","classNames","noop","usePlatform","usePrevious","useTimeout","useWaitTransitionFinish","blurActiveElement","canUseDOM","useDOM","getNavId","Platform","animationEvent","useIsomorphicLayoutEffect","warnOnce","useScroll","useConfigProvider","NavViewIdContext","NavTransitionProvider","NavTransitionDirectionProvider","useSplitCol","Touch","getSwipeBackPredicates","hasHorizontalScrollableElementWithScrolledToLeft","swipeBackExcluded","SwipeBackResults","scrollsCache","warn","View","_param","activePanelProp","activePanel","history","nav","onTransition","onSwipeBack","onSwipeBackStart","onSwipeBackCancelProp","onSwipeBackCancel","children","className","restProps","_object_without_properties","id","scrolls","useRef","afterTransition","useEffect","current","panelNodes","_useDOM","window","document","scroll","configProvider","splitCol","platform","_React_useState","_sliced_to_array","useState","animated","setAnimated","_React_useState1","visiblePanels","setVisiblePanels","_React_useState2","setActivePanel","_React_useState3","undefined","isBack","setIsBack","_React_useState4","prevPanel","setPrevPanel","_React_useState5","nextPanel","setNextPanel","swipeBackPrevented","_React_useState6","swipingBack","setSwipingBack","_React_useState7","swipeBackStartX","setSwipeBackStartX","_React_useState8","swipeBackShift","setSwipeBackShift","_React_useState9","swipeBackNextPanel","setSwipeBackNextPanel","_React_useState10","swipeBackPrevPanel","setSwipeBackPrevPanel","_React_useState11","swipeBackResult","setSwipeBackResult","_React_useState12","browserSwipe","setBrowserSwipe","prevActivePanel","prevSwipingBack","prevBrowserSwipe","prevSwipeBackResult","prevSwipeBackPrevPanel","prevOnTransition","panels","Children","toArray","filter","panel","panelId","props","includes","disableAnimation","transitionMotionEnabled","animate","VKCOM","iOSSwipeBackSimulationEnabled","IOS","isWebView","Boolean","pickPanel","flushTransition","useCallback","isBackTransition","scrollTo","from","to","transitionEndHandler","e","animationName","waitTransitionFinish","animationFinishTimeout","onSwipeBackSuccess","swipingBackTransitionEndHandler","propertyName","target","handleTouchMoveXForNativeIOSSwipeBackOrSwipeNext","event","_getSwipeBackPredicates","startX","shiftX","innerWidth","swipeBackTriggered","viewportStartEdgeTouched","viewportEndEdgeTouched","handleTouchMoveXForIOSSwipeBackSimulation","swipedToOpposite","length","originalEvent","payload","getScroll","y","slice","handleTouchEndForIOSSwipeBackSimulation","speed","duration","_window_innerWidth","calcPanelSwipeStyles","isPrev","isNext","prevPanelTranslate","concat","nextPanelTranslate","transform","WebkitTransform","calcPanelSwipeBackOverlayStyles","calculatedOpacity","opacityOnSwipeEnd","display","opacity","firstLayerId","map","find","supported","set","createElement","Provider","value","_object_spread_props","_object_spread","Component","onMoveX","onEnd","isTransitionTarget","compensateScroll","_scrolls_current_panelId","onAnimationEnd","ref","el","style","key","marginTop","entering"],"sources":["../../../src/components/View/View.tsx"],"sourcesContent":["import * as React from 'react';\nimport { classNames, noop } from '@vkontakte/vkjs';\nimport { usePlatform } from '../../hooks/usePlatform';\nimport { usePrevious } from '../../hooks/usePrevious';\nimport { useTimeout } from '../../hooks/useTimeout';\nimport { useWaitTransitionFinish } from '../../hooks/useWaitTransitionFinish';\nimport { blurActiveElement, canUseDOM, useDOM } from '../../lib/dom';\nimport { getNavId, NavIdProps } from '../../lib/getNavId';\nimport { Platform } from '../../lib/platform';\nimport { animationEvent } from '../../lib/supportEvents';\nimport { useIsomorphicLayoutEffect } from '../../lib/useIsomorphicLayoutEffect';\nimport { warnOnce } from '../../lib/warnOnce';\nimport { HTMLAttributesWithRootRef } from '../../types';\nimport { useScroll } from '../AppRoot/ScrollContext';\nimport { useConfigProvider } from '../ConfigProvider/ConfigProviderContext';\nimport { NavViewIdContext } from '../NavIdContext/NavIdContext';\nimport { NavTransitionProvider } from '../NavTransitionContext/NavTransitionContext';\nimport { NavTransitionDirectionProvider } from '../NavTransitionDirectionContext/NavTransitionDirectionContext';\nimport { useSplitCol } from '../SplitCol/SplitColContext';\nimport { Touch, TouchEvent } from '../Touch/Touch';\nimport {\n  getSwipeBackPredicates,\n  hasHorizontalScrollableElementWithScrolledToLeft,\n  swipeBackExcluded,\n} from './utils';\nimport styles from './View.module.css';\n\nenum SwipeBackResults {\n  fail = 1,\n  success,\n}\n\ninterface Scrolls {\n  [index: string]: number | undefined;\n}\n\ninterface ViewsScrolls {\n  [index: string]: Scrolls;\n}\n\nexport let scrollsCache: ViewsScrolls = {};\n\nexport interface ViewProps extends HTMLAttributesWithRootRef<HTMLElement>, NavIdProps {\n  activePanel: string;\n  onTransition?(params: { isBack: boolean; from: string; to: string }): void;\n  /**\n   * callback свайпа назад\n   */\n  onSwipeBack?(): void;\n  /**\n   * callback начала анимации свайпа назад.\n   *\n   * Чтобы остановить свайп назад, возвращайте `\"prevent\"`.\n   */\n  onSwipeBackStart?(activePanel: string | null): void | 'prevent';\n  /**\n   * callback завершения анимации отмененного пользователем свайпа\n   */\n  onSwipeBackCancel?(): void;\n  history?: string[];\n\n  children: React.ReactElement | Iterable<React.ReactElement>;\n}\n\nconst warn = warnOnce('View');\n\n/**\n * @see https://vkcom.github.io/VKUI/#/View\n */\nexport const View = ({\n  activePanel: activePanelProp,\n  history,\n  nav,\n  onTransition,\n  onSwipeBack,\n  onSwipeBackStart,\n  onSwipeBackCancel: onSwipeBackCancelProp,\n  children,\n  className,\n  ...restProps\n}: ViewProps) => {\n  const id = getNavId({ nav, id: restProps.id });\n  const scrolls = React.useRef(scrollsCache[id as string] || {});\n  const afterTransition = React.useRef(noop);\n\n  React.useEffect(() => () => {\n    if (id) {\n      scrollsCache[id] = scrolls.current;\n    }\n  });\n\n  const panelNodes = React.useRef<{ [id: string]: HTMLDivElement | null }>({});\n\n  const { window, document } = useDOM();\n  const scroll = useScroll();\n  const configProvider = useConfigProvider();\n  const splitCol = useSplitCol();\n  const platform = usePlatform();\n\n  const [animated, setAnimated] = React.useState(false);\n\n  const [visiblePanels, setVisiblePanels] = React.useState([activePanelProp]);\n  const [activePanel, setActivePanel] = React.useState<string | null>(activePanelProp);\n  const [isBack, setIsBack] = React.useState<boolean | undefined>(undefined);\n  const [prevPanel, setPrevPanel] = React.useState<string | null>(null);\n  const [nextPanel, setNextPanel] = React.useState<string | null>(null);\n\n  const swipeBackPrevented = React.useRef<boolean>(false);\n  const [swipingBack, setSwipingBack] = React.useState<boolean | undefined>(undefined);\n  const [swipeBackStartX, setSwipeBackStartX] = React.useState<number>(0);\n  const [swipeBackShift, setSwipeBackShift] = React.useState<number>(0);\n  const [swipeBackNextPanel, setSwipeBackNextPanel] = React.useState<string | null>(null);\n  const [swipeBackPrevPanel, setSwipeBackPrevPanel] = React.useState<string | null>(null);\n  const [swipeBackResult, setSwipeBackResult] = React.useState<SwipeBackResults | null>(null);\n\n  const [browserSwipe, setBrowserSwipe] = React.useState(false);\n\n  const prevActivePanel = usePrevious(activePanelProp);\n  const prevSwipingBack = usePrevious(swipingBack);\n  const prevBrowserSwipe = usePrevious(browserSwipe);\n  const prevSwipeBackResult = usePrevious(swipeBackResult);\n  const prevSwipeBackPrevPanel = usePrevious(swipeBackPrevPanel);\n  const prevOnTransition = usePrevious(onTransition);\n\n  const panels = (React.Children.toArray(children) as React.ReactElement[]).filter(\n    (panel: React.ReactElement) => {\n      const panelId = getNavId(panel.props, warn);\n\n      return (\n        (panelId !== undefined && visiblePanels.includes(panelId)) ||\n        panelId === swipeBackPrevPanel ||\n        panelId === swipeBackNextPanel\n      );\n    },\n  );\n\n  const disableAnimation =\n    !configProvider.transitionMotionEnabled || !splitCol.animate || platform === Platform.VKCOM;\n  const iOSSwipeBackSimulationEnabled =\n    !disableAnimation &&\n    platform === Platform.IOS &&\n    configProvider.isWebView &&\n    Boolean(onSwipeBack);\n\n  const pickPanel = (id: string | null) => {\n    if (id === null) {\n      return null;\n    }\n    return panelNodes.current[id];\n  };\n\n  const flushTransition = React.useCallback(\n    (prevPanel: string, isBackTransition: boolean) => {\n      if (isBackTransition) {\n        scrolls.current[prevPanel] = 0;\n      }\n      setPrevPanel(null);\n      setNextPanel(null);\n      setVisiblePanels([activePanelProp]);\n      setActivePanel(activePanelProp);\n      setAnimated(false);\n      setIsBack(isBackTransition);\n\n      afterTransition.current = () => {\n        scroll?.scrollTo(0, isBackTransition ? scrolls.current[activePanelProp] : 0);\n        onTransition &&\n          onTransition({\n            isBack: isBackTransition,\n            from: prevPanel,\n            to: activePanelProp,\n          });\n      };\n    },\n    [activePanelProp, onTransition, scroll],\n  );\n\n  useIsomorphicLayoutEffect(() => {\n    afterTransition.current();\n    afterTransition.current = noop;\n  }, [afterTransition.current]);\n\n  const transitionEndHandler = React.useCallback(\n    (e?: React.AnimationEvent): void => {\n      if (\n        (!e ||\n          [\n            styles['animation-ios-next-forward'],\n            styles['animation-ios-prev-back'],\n            styles['animation-view-next-forward'],\n            styles['animation-view-prev-back'],\n          ].includes(e.animationName)) &&\n        prevPanel !== null\n      ) {\n        flushTransition(prevPanel, Boolean(isBack));\n      }\n    },\n    [flushTransition, isBack, prevPanel],\n  );\n\n  const { waitTransitionFinish } = useWaitTransitionFinish();\n  const animationFinishTimeout = useTimeout(\n    transitionEndHandler,\n    platform === Platform.IOS ? 600 : 300,\n  );\n\n  const onSwipeBackSuccess = React.useCallback(() => {\n    onSwipeBack && onSwipeBack();\n  }, [onSwipeBack]);\n\n  const onSwipeBackCancel = React.useCallback(() => {\n    onSwipeBackCancelProp && onSwipeBackCancelProp();\n    setSwipeBackPrevPanel(null);\n    setSwipeBackNextPanel(null);\n    setSwipingBack(false);\n    setSwipeBackResult(null);\n    setSwipeBackStartX(0);\n    setSwipeBackShift(0);\n  }, [onSwipeBackCancelProp]);\n\n  const swipingBackTransitionEndHandler = React.useCallback(\n    (e?: TransitionEvent): void => {\n      // indexOf because of vendor prefixes in old browsers\n      if (\n        !e ||\n        (e?.propertyName.includes('transform') && e?.target === pickPanel(swipeBackNextPanel))\n      ) {\n        switch (swipeBackResult) {\n          case SwipeBackResults.fail:\n            onSwipeBackCancel();\n            break;\n          case SwipeBackResults.success:\n            onSwipeBackSuccess();\n        }\n      }\n    },\n    [onSwipeBackCancel, onSwipeBackSuccess, swipeBackNextPanel, swipeBackResult],\n  );\n\n  const handleTouchMoveXForNativeIOSSwipeBackOrSwipeNext = (event: TouchEvent) => {\n    if (browserSwipe) {\n      return;\n    }\n    const { swipeBackTriggered, viewportStartEdgeTouched, viewportEndEdgeTouched } =\n      getSwipeBackPredicates(event.startX, event.shiftX, window!.innerWidth);\n\n    if ((viewportStartEdgeTouched || viewportEndEdgeTouched) && swipeBackTriggered) {\n      setBrowserSwipe(true);\n    }\n  };\n\n  const handleTouchMoveXForIOSSwipeBackSimulation = (event: TouchEvent) => {\n    if (swipeBackPrevented.current || swipeBackExcluded(event)) {\n      return;\n    }\n\n    const { swipedToOpposite, swipeBackTriggered, viewportStartEdgeTouched } =\n      getSwipeBackPredicates(event.startX, event.shiftX, window!.innerWidth);\n\n    if (animated && swipeBackTriggered) {\n      return;\n    }\n\n    if (!swipingBack && history && history.length > 1) {\n      if (swipedToOpposite) {\n        swipeBackPrevented.current = true;\n        return;\n      }\n\n      if (!swipeBackTriggered) {\n        return;\n      }\n\n      if (\n        !viewportStartEdgeTouched &&\n        hasHorizontalScrollableElementWithScrolledToLeft(event.originalEvent.target as HTMLElement)\n      ) {\n        swipeBackPrevented.current = true;\n        return;\n      }\n      // Начался свайп назад\n      if (onSwipeBackStart) {\n        const payload = onSwipeBackStart(activePanel);\n        if (payload === 'prevent') {\n          swipeBackPrevented.current = true;\n          return;\n        }\n      }\n\n      if (activePanel !== null) {\n        // Note: вызываем закрытие клавиатуры. В iOS это нативное поведение при свайпе.\n        blurActiveElement(document);\n        scrolls.current[activePanel] = scroll?.getScroll().y;\n      }\n\n      setSwipingBack(true);\n      setSwipeBackStartX(event.startX);\n      setSwipeBackPrevPanel(activePanel);\n      setSwipeBackNextPanel(history.slice(-2)[0]);\n    }\n\n    if (swipingBack) {\n      if (event.shiftX < 0) {\n        setSwipeBackShift(0);\n      } else if (event.shiftX > window!.innerWidth - swipeBackStartX) {\n        setSwipeBackShift(window!.innerWidth);\n      } else {\n        setSwipeBackShift(event.shiftX);\n      }\n    }\n  };\n\n  const handleTouchEndForIOSSwipeBackSimulation = (event: TouchEvent) => {\n    swipeBackPrevented.current = false;\n\n    if (swipingBack) {\n      const speed = (swipeBackShift / event.duration) * 1000;\n      if (swipeBackShift === 0) {\n        onSwipeBackCancel();\n      } else if (swipeBackShift >= (window!.innerWidth ?? 0)) {\n        onSwipeBackSuccess();\n      } else if (speed > 250 || swipeBackShift >= window!.innerWidth / 2) {\n        setSwipeBackResult(SwipeBackResults.success);\n      } else {\n        setSwipeBackResult(SwipeBackResults.fail);\n      }\n    }\n  };\n\n  const calcPanelSwipeStyles = (panelId: string | undefined): React.CSSProperties => {\n    if (!canUseDOM || !window) {\n      return {};\n    }\n\n    const isPrev = panelId === swipeBackPrevPanel;\n    const isNext = panelId === swipeBackNextPanel;\n\n    if ((!isPrev && !isNext) || swipeBackResult) {\n      return {};\n    }\n\n    let prevPanelTranslate = `${swipeBackShift}px`;\n    let nextPanelTranslate = `${-50 + (swipeBackShift * 100) / window.innerWidth / 2}%`;\n\n    if (isNext) {\n      return {\n        transform: `translate3d(${nextPanelTranslate}, 0, 0)`,\n        WebkitTransform: `translate3d(${nextPanelTranslate}, 0, 0)`,\n      };\n    }\n    if (isPrev) {\n      return {\n        transform: `translate3d(${prevPanelTranslate}, 0, 0)`,\n        WebkitTransform: `translate3d(${prevPanelTranslate}, 0, 0)`,\n      };\n    }\n\n    return {};\n  };\n\n  const calcPanelSwipeBackOverlayStyles = (panelId?: string): React.CSSProperties => {\n    if (!canUseDOM || !window) {\n      return {};\n    }\n\n    const isNext = panelId === swipeBackNextPanel;\n    if (!isNext) {\n      return {};\n    }\n\n    const calculatedOpacity = 1 - swipeBackShift / window.innerWidth;\n    const opacityOnSwipeEnd =\n      swipeBackResult === SwipeBackResults.success\n        ? 0\n        : swipeBackResult === SwipeBackResults.fail\n        ? 1\n        : null;\n\n    return {\n      display: 'block',\n      opacity: opacityOnSwipeEnd === null ? calculatedOpacity : opacityOnSwipeEnd,\n    };\n  };\n\n  React.useEffect(() => {\n    // Нужен переход\n    if (\n      prevActivePanel &&\n      prevActivePanel !== activePanelProp &&\n      !prevSwipingBack &&\n      !prevBrowserSwipe\n    ) {\n      const firstLayerId = (React.Children.toArray(children) as React.ReactElement[])\n        .map((panel) => getNavId(panel.props, warn))\n        .find((id) => id === prevActivePanel || id === activePanelProp);\n\n      const isBackTransition = firstLayerId === activePanelProp;\n      scrolls.current[prevActivePanel] = scroll?.getScroll().y;\n\n      if (disableAnimation) {\n        flushTransition(prevActivePanel, isBackTransition);\n      } else {\n        blurActiveElement(document);\n\n        setVisiblePanels([prevActivePanel, activePanelProp]);\n        setPrevPanel(prevActivePanel);\n        setNextPanel(activePanelProp);\n        setActivePanel(null);\n        setAnimated(true);\n        setIsBack(isBackTransition);\n\n        // Фолбек анимации перехода\n        if (!animationEvent.supported) {\n          animationFinishTimeout.set();\n        }\n      }\n    }\n\n    // Закончилась анимация свайпа назад\n    if (prevActivePanel && prevActivePanel !== activePanelProp && prevSwipingBack) {\n      const nextPanel = activePanelProp;\n      const prevPanel = prevActivePanel;\n      if (prevSwipeBackPrevPanel) {\n        scrolls.current[prevSwipeBackPrevPanel] = 0;\n      }\n\n      setSwipeBackPrevPanel(null);\n      setSwipeBackNextPanel(null);\n      setSwipingBack(false);\n      setSwipeBackResult(null);\n      setSwipeBackStartX(0);\n      setSwipeBackShift(0);\n      setActivePanel(nextPanel);\n      setVisiblePanels([nextPanel]);\n      setIsBack(true);\n\n      afterTransition.current = () => {\n        if (nextPanel !== null) {\n          scroll?.scrollTo(0, scrolls.current[nextPanel]);\n        }\n        prevOnTransition &&\n          prevOnTransition({\n            isBack: true,\n            from: prevPanel,\n            to: nextPanel,\n          });\n      };\n    }\n\n    // Началась анимация завершения свайпа назад.\n    if (!prevSwipeBackResult && swipeBackResult) {\n      waitTransitionFinish(\n        pickPanel(swipeBackNextPanel),\n        swipingBackTransitionEndHandler,\n        platform === Platform.IOS ? 600 : 300,\n      );\n    }\n\n    // Если свайп назад отменился (когда пользователь недостаточно сильно свайпнул)\n    if (prevSwipeBackResult === SwipeBackResults.fail && !swipeBackResult && activePanel !== null) {\n      scroll?.scrollTo(0, scrolls.current[activePanel]);\n    }\n\n    // Закончился Safari свайп\n    if (prevActivePanel !== activePanelProp && browserSwipe) {\n      setBrowserSwipe(false);\n      setNextPanel(null);\n      setPrevPanel(null);\n      setAnimated(false);\n      setVisiblePanels([activePanelProp]);\n      setActivePanel(activePanelProp);\n    }\n  }, [\n    activePanelProp,\n    activePanel,\n    animationFinishTimeout,\n    browserSwipe,\n    children,\n    disableAnimation,\n    document,\n    flushTransition,\n    platform,\n    prevActivePanel,\n    prevBrowserSwipe,\n    prevOnTransition,\n    prevSwipeBackPrevPanel,\n    prevSwipeBackResult,\n    prevSwipingBack,\n    scroll,\n    swipeBackNextPanel,\n    swipeBackResult,\n    swipingBackTransitionEndHandler,\n    waitTransitionFinish,\n  ]);\n\n  return (\n    <NavViewIdContext.Provider value={id}>\n      <Touch\n        Component=\"section\"\n        {...restProps}\n        className={classNames(\n          styles['View'],\n          platform === Platform.IOS && classNames(styles['View--ios'], 'vkuiInternalView--ios'),\n          !disableAnimation && animated && styles['View--animated'],\n          !disableAnimation && swipingBack && styles['View--swiping-back'],\n          disableAnimation && styles['View--no-motion'],\n          className,\n        )}\n        onMoveX={\n          iOSSwipeBackSimulationEnabled\n            ? handleTouchMoveXForIOSSwipeBackSimulation\n            : platform === Platform.IOS\n            ? handleTouchMoveXForNativeIOSSwipeBackOrSwipeNext\n            : undefined\n        }\n        onEnd={iOSSwipeBackSimulationEnabled ? handleTouchEndForIOSSwipeBackSimulation : undefined}\n      >\n        <div className={styles['View__panels']}>\n          {panels.map((panel: React.ReactElement) => {\n            const panelId = getNavId(panel.props, warn);\n            const isPrev = panelId === prevPanel || panelId === swipeBackPrevPanel;\n            const isTransitionTarget = animated && panelId === (isBack ? prevPanel : nextPanel);\n            const compensateScroll =\n              isPrev || panelId === swipeBackNextPanel || (panelId === nextPanel && isBack);\n\n            return (\n              <div\n                className={classNames(\n                  styles['View__panel'],\n                  panelId === activePanel && styles['View__panel--active'],\n                  panelId === prevPanel && styles['View__panel--prev'],\n                  panelId === nextPanel && styles['View__panel--next'],\n                  panelId === swipeBackPrevPanel && styles['View__panel--swipe-back-prev'],\n                  panelId === swipeBackNextPanel && styles['View__panel--swipe-back-next'],\n                  swipeBackResult === SwipeBackResults.success &&\n                    styles['View__panel--swipe-back-success'],\n                  swipeBackResult === SwipeBackResults.fail &&\n                    styles['View__panel--swipe-back-failed'],\n                )}\n                onAnimationEnd={isTransitionTarget ? transitionEndHandler : undefined}\n                ref={(el) => panelId !== undefined && (panelNodes.current[panelId] = el)}\n                style={calcPanelSwipeStyles(panelId)}\n                key={panelId}\n              >\n                {platform === Platform.IOS && (\n                  <div\n                    className={styles['View__panel-overlay']}\n                    style={calcPanelSwipeBackOverlayStyles(panelId)}\n                  />\n                )}\n                <div\n                  className={styles['View__panel-in']}\n                  style={{\n                    marginTop: compensateScroll ? -(scrolls.current[panelId] ?? 0) : undefined,\n                  }}\n                >\n                  <NavTransitionDirectionProvider isBack={swipingBack || isBack}>\n                    <NavTransitionProvider\n                      entering={panelId === nextPanel || panelId === swipeBackNextPanel}\n                    >\n                      {panel}\n                    </NavTransitionProvider>\n                  </NavTransitionDirectionProvider>\n                </div>\n              </div>\n            );\n          })}\n        </div>\n      </Touch>\n    </NavViewIdContext.Provider>\n  );\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}