{"ast":null,"code":"import { _ as _async_to_generator } from \"@swc/helpers/_/_async_to_generator\";\nimport { _ as _define_property } from \"@swc/helpers/_/_define_property\";\nimport { _ as _object_spread } from \"@swc/helpers/_/_object_spread\";\nimport { _ as _object_spread_props } from \"@swc/helpers/_/_object_spread_props\";\nimport { _ as _object_without_properties } from \"@swc/helpers/_/_object_without_properties\";\nimport { _ as _to_consumable_array } from \"@swc/helpers/_/_to_consumable_array\";\nimport { _ as _ts_generator } from \"@swc/helpers/_/_ts_generator\";\nimport { getSideAxis, getAlignmentAxis, getAxisLength, getSide, getAlignment, evaluate, getPaddingObject, rectToClientRect, min, clamp, placements, getAlignmentSides, getOppositeAlignmentPlacement, getOppositePlacement, getExpandedPlacements, getOppositeAxisPlacements, sides, max, getOppositeAxis } from '../../utils/dist/floating-ui.utils.esm.js';\nexport { rectToClientRect } from '../../utils/dist/floating-ui.utils.esm.js';\nfunction computeCoordsFromPlacement(_ref, placement, rtl) {\n  var reference = _ref.reference,\n    floating = _ref.floating;\n  var sideAxis = getSideAxis(placement);\n  var alignmentAxis = getAlignmentAxis(placement);\n  var alignLength = getAxisLength(alignmentAxis);\n  var side = getSide(placement);\n  var isVertical = sideAxis === \"y\";\n  var commonX = reference.x + reference.width / 2 - floating.width / 2;\n  var commonY = reference.y + reference.height / 2 - floating.height / 2;\n  var commonAlign = reference[alignLength] / 2 - floating[alignLength] / 2;\n  var coords;\n  switch (side) {\n    case \"top\":\n      coords = {\n        x: commonX,\n        y: reference.y - floating.height\n      };\n      break;\n    case \"bottom\":\n      coords = {\n        x: commonX,\n        y: reference.y + reference.height\n      };\n      break;\n    case \"right\":\n      coords = {\n        x: reference.x + reference.width,\n        y: commonY\n      };\n      break;\n    case \"left\":\n      coords = {\n        x: reference.x - floating.width,\n        y: commonY\n      };\n      break;\n    default:\n      coords = {\n        x: reference.x,\n        y: reference.y\n      };\n  }\n  switch (getAlignment(placement)) {\n    case \"start\":\n      coords[alignmentAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);\n      break;\n    case \"end\":\n      coords[alignmentAxis] += commonAlign * (rtl && isVertical ? -1 : 1);\n      break;\n  }\n  return coords;\n}\n/**\n * Computes the `x` and `y` coordinates that will place the floating element\n * next to a reference element when it is given a certain positioning strategy.\n *\n * This export does not have any `platform` interface logic. You will need to\n * write one for the platform you are using Floating UI with.\n */\nvar computePosition = function () {\n  var _ref = _async_to_generator(function (reference, floating, config) {\n    var _config_placement, placement, _config_strategy, strategy, _config_middleware, middleware, platform, validMiddleware, rtl, rects, _computeCoordsFromPlacement, x, y, statefulPlacement, middlewareData, resetCount, i, _validMiddleware_i, name, fn, _ref, nextX, nextY, data, reset, _tmp, ref;\n    return _ts_generator(this, function (_state) {\n      switch (_state.label) {\n        case 0:\n          _config_placement = config.placement, placement = _config_placement === void 0 ? \"bottom\" : _config_placement, _config_strategy = config.strategy, strategy = _config_strategy === void 0 ? \"absolute\" : _config_strategy, _config_middleware = config.middleware, middleware = _config_middleware === void 0 ? [] : _config_middleware, platform = config.platform;\n          validMiddleware = middleware.filter(Boolean);\n          return [4, platform.isRTL == null ? void 0 : platform.isRTL(floating)];\n        case 1:\n          rtl = _state.sent();\n          return [4, platform.getElementRects({\n            reference: reference,\n            floating: floating,\n            strategy: strategy\n          })];\n        case 2:\n          rects = _state.sent();\n          _computeCoordsFromPlacement = computeCoordsFromPlacement(rects, placement, rtl), x = _computeCoordsFromPlacement.x, y = _computeCoordsFromPlacement.y;\n          statefulPlacement = placement;\n          middlewareData = {};\n          resetCount = 0;\n          i = 0;\n          _state.label = 3;\n        case 3:\n          if (!(i < validMiddleware.length)) return [3, 11];\n          _validMiddleware_i = validMiddleware[i], name = _validMiddleware_i.name, fn = _validMiddleware_i.fn;\n          return [4, fn({\n            x: x,\n            y: y,\n            initialPlacement: placement,\n            placement: statefulPlacement,\n            strategy: strategy,\n            middlewareData: middlewareData,\n            rects: rects,\n            platform: platform,\n            elements: {\n              reference: reference,\n              floating: floating\n            }\n          })];\n        case 4:\n          _ref = _state.sent(), nextX = _ref.x, nextY = _ref.y, data = _ref.data, reset = _ref.reset;\n          x = nextX != null ? nextX : x;\n          y = nextY != null ? nextY : y;\n          middlewareData = _object_spread_props(_object_spread({}, middlewareData), _define_property({}, name, _object_spread({}, middlewareData[name], data)));\n          if (!(reset && resetCount <= 50)) return [3, 10];\n          resetCount++;\n          if (!(typeof reset === \"object\")) return [3, 9];\n          if (reset.placement) {\n            statefulPlacement = reset.placement;\n          }\n          if (!reset.rects) return [3, 8];\n          if (!(reset.rects === true)) return [3, 6];\n          return [4, platform.getElementRects({\n            reference: reference,\n            floating: floating,\n            strategy: strategy\n          })];\n        case 5:\n          _tmp = _state.sent();\n          return [3, 7];\n        case 6:\n          _tmp = reset.rects;\n          _state.label = 7;\n        case 7:\n          rects = _tmp;\n          _state.label = 8;\n        case 8:\n          ref = computeCoordsFromPlacement(rects, statefulPlacement, rtl), x = ref.x, y = ref.y, ref;\n          _state.label = 9;\n        case 9:\n          i = -1;\n          return [3, 10];\n        case 10:\n          i++;\n          return [3, 3];\n        case 11:\n          return [2, {\n            x: x,\n            y: y,\n            placement: statefulPlacement,\n            strategy: strategy,\n            middlewareData: middlewareData\n          }];\n      }\n    });\n  });\n  return function computePosition(reference, floating, config) {\n    return _ref.apply(this, arguments);\n  };\n}();\nfunction detectOverflow(state, options) {\n  return _detectOverflow.apply(this, arguments);\n}\nfunction _detectOverflow() {\n  _detectOverflow =\n  /**\n  * Resolves with an object of overflow side offsets that determine how much the\n  * element is overflowing a given clipping boundary on each side.\n  * - positive = overflowing the boundary by that number of pixels\n  * - negative = how many pixels left before it will overflow\n  * - 0 = lies flush with the boundary\n  * @see https://floating-ui.com/docs/detectOverflow\n  */\n  _async_to_generator(function (state, options) {\n    var _await$platform$isEle, x, y, platform, rects, elements, strategy, _evaluate, _evaluate_boundary, boundary, _evaluate_rootBoundary, rootBoundary, _evaluate_elementContext, elementContext, _evaluate_altBoundary, altBoundary, _evaluate_padding, padding, paddingObject, altContext, element, clippingClientRect, _, _tmp, _tmp1, _tmp2, rect, offsetParent, offsetScale, _tmp3, elementClientRect, _tmp4;\n    return _ts_generator(this, function (_state) {\n      switch (_state.label) {\n        case 0:\n          if (options === void 0) {\n            options = {};\n          }\n          x = state.x, y = state.y, platform = state.platform, rects = state.rects, elements = state.elements, strategy = state.strategy;\n          _evaluate = evaluate(options, state), _evaluate_boundary = _evaluate.boundary, boundary = _evaluate_boundary === void 0 ? \"clippingAncestors\" : _evaluate_boundary, _evaluate_rootBoundary = _evaluate.rootBoundary, rootBoundary = _evaluate_rootBoundary === void 0 ? \"viewport\" : _evaluate_rootBoundary, _evaluate_elementContext = _evaluate.elementContext, elementContext = _evaluate_elementContext === void 0 ? \"floating\" : _evaluate_elementContext, _evaluate_altBoundary = _evaluate.altBoundary, altBoundary = _evaluate_altBoundary === void 0 ? false : _evaluate_altBoundary, _evaluate_padding = _evaluate.padding, padding = _evaluate_padding === void 0 ? 0 : _evaluate_padding;\n          paddingObject = getPaddingObject(padding);\n          altContext = elementContext === \"floating\" ? \"reference\" : \"floating\";\n          element = elements[altBoundary ? altContext : elementContext];\n          _ = platform.getClippingRect;\n          _tmp = {};\n          return [4, platform.isElement == null ? void 0 : platform.isElement(element)];\n        case 1:\n          if (!((_await$platform$isEle = _state.sent()) != null ? _await$platform$isEle : true)) return [3, 2];\n          _tmp1 = element;\n          return [3, 5];\n        case 2:\n          _tmp2 = element.contextElement;\n          if (_tmp2) return [3, 4];\n          return [4, platform.getDocumentElement == null ? void 0 : platform.getDocumentElement(elements.floating)];\n        case 3:\n          _tmp2 = _state.sent();\n          _state.label = 4;\n        case 4:\n          _tmp1 = _tmp2;\n          _state.label = 5;\n        case 5:\n          return [4, _.apply(platform, [(_tmp.element = _tmp1, _tmp.boundary = boundary, _tmp.rootBoundary = rootBoundary, _tmp.strategy = strategy, _tmp)])];\n        case 6:\n          clippingClientRect = rectToClientRect.apply(void 0, [_state.sent()]);\n          rect = elementContext === \"floating\" ? _object_spread_props(_object_spread({}, rects.floating), {\n            x: x,\n            y: y\n          }) : rects.reference;\n          return [4, platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(elements.floating)];\n        case 7:\n          offsetParent = _state.sent();\n          return [4, platform.isElement == null ? void 0 : platform.isElement(offsetParent)];\n        case 8:\n          if (!_state.sent()) return [3, 10];\n          return [4, platform.getScale == null ? void 0 : platform.getScale(offsetParent)];\n        case 9:\n          _tmp3 = _state.sent() || {\n            x: 1,\n            y: 1\n          };\n          return [3, 11];\n        case 10:\n          _tmp3 = {\n            x: 1,\n            y: 1\n          };\n          _state.label = 11;\n        case 11:\n          offsetScale = _tmp3;\n          if (!platform.convertOffsetParentRelativeRectToViewportRelativeRect) return [3, 13];\n          return [4, platform.convertOffsetParentRelativeRectToViewportRelativeRect({\n            rect: rect,\n            offsetParent: offsetParent,\n            strategy: strategy\n          })];\n        case 12:\n          _tmp4 = _state.sent();\n          return [3, 14];\n        case 13:\n          _tmp4 = rect;\n          _state.label = 14;\n        case 14:\n          elementClientRect = rectToClientRect.apply(void 0, [_tmp4]);\n          return [2, {\n            top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,\n            bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,\n            left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,\n            right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x\n          }];\n      }\n    });\n  });\n  return _detectOverflow.apply(this, arguments);\n}\n/**\n * Provides data to position an inner element of the floating element so that it\n * appears centered to the reference element.\n * @see https://floating-ui.com/docs/arrow\n */\nvar arrow = function (options) {\n  return {\n    name: \"arrow\",\n    options: options,\n    fn: function fn(state) {\n      return _async_to_generator(function () {\n        var x, y, placement, rects, platform, elements, middlewareData, _ref, element, _ref_padding, padding, paddingObject, coords, axis, length, arrowDimensions, isYAxis, minProp, maxProp, clientProp, endDiff, startDiff, arrowOffsetParent, clientSize, _tmp, centerToReference, largestPossiblePadding, minPadding, maxPadding, min$1, max, center, offset, shouldAddOffset, alignmentOffset, _obj, _obj1;\n        return _ts_generator(this, function (_state) {\n          switch (_state.label) {\n            case 0:\n              x = state.x, y = state.y, placement = state.placement, rects = state.rects, platform = state.platform, elements = state.elements, middlewareData = state.middlewareData;\n              // Since `element` is required, we don't Partial<> the type.\n              _ref = evaluate(options, state) || {}, element = _ref.element, _ref_padding = _ref.padding, padding = _ref_padding === void 0 ? 0 : _ref_padding;\n              if (element == null) {\n                return [2, {}];\n              }\n              paddingObject = getPaddingObject(padding);\n              coords = {\n                x: x,\n                y: y\n              };\n              axis = getAlignmentAxis(placement);\n              length = getAxisLength(axis);\n              return [4, platform.getDimensions(element)];\n            case 1:\n              arrowDimensions = _state.sent();\n              isYAxis = axis === \"y\";\n              minProp = isYAxis ? \"top\" : \"left\";\n              maxProp = isYAxis ? \"bottom\" : \"right\";\n              clientProp = isYAxis ? \"clientHeight\" : \"clientWidth\";\n              endDiff = rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length];\n              startDiff = coords[axis] - rects.reference[axis];\n              return [4, platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(element)];\n            case 2:\n              arrowOffsetParent = _state.sent();\n              clientSize = arrowOffsetParent ? arrowOffsetParent[clientProp] : 0;\n              _tmp = !clientSize;\n              if (_tmp) return [3, 4];\n              return [4, platform.isElement == null ? void 0 : platform.isElement(arrowOffsetParent)];\n            case 3:\n              _tmp = !_state.sent();\n              _state.label = 4;\n            case 4:\n              // DOM platform can return `window` as the `offsetParent`.\n              if (_tmp) {\n                clientSize = elements.floating[clientProp] || rects.floating[length];\n              }\n              centerToReference = endDiff / 2 - startDiff / 2;\n              // If the padding is large enough that it causes the arrow to no longer be\n              // centered, modify the padding so that it is centered.\n              largestPossiblePadding = clientSize / 2 - arrowDimensions[length] / 2 - 1;\n              minPadding = min(paddingObject[minProp], largestPossiblePadding);\n              maxPadding = min(paddingObject[maxProp], largestPossiblePadding);\n              // Make sure the arrow doesn't overflow the floating element if the center\n              // point is outside the floating element's bounds.\n              min$1 = minPadding;\n              max = clientSize - arrowDimensions[length] - maxPadding;\n              center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;\n              offset = clamp(min$1, center, max);\n              // If the reference is small enough that the arrow's padding causes it to\n              // to point to nothing for an aligned placement, adjust the offset of the\n              // floating element itself. To ensure `shift()` continues to take action,\n              // a single reset is performed when this is true.\n              shouldAddOffset = !middlewareData.arrow && getAlignment(placement) != null && center != offset && rects.reference[length] / 2 - (center < min$1 ? minPadding : maxPadding) - arrowDimensions[length] / 2 < 0;\n              alignmentOffset = shouldAddOffset ? center < min$1 ? center - min$1 : center - max : 0;\n              return [2, (_obj1 = {}, _define_property(_obj1, axis, coords[axis] + alignmentOffset), _define_property(_obj1, \"data\", _object_spread((_obj = {}, _define_property(_obj, axis, offset), _define_property(_obj, \"centerOffset\", center - offset - alignmentOffset), _obj), shouldAddOffset && {\n                alignmentOffset: alignmentOffset\n              })), _define_property(_obj1, \"reset\", shouldAddOffset), _obj1)];\n          }\n        });\n      })();\n    }\n  };\n};\nfunction getPlacementList(alignment, autoAlignment, allowedPlacements) {\n  var allowedPlacementsSortedByAlignment = alignment ? _to_consumable_array(allowedPlacements.filter(function (placement) {\n    return getAlignment(placement) === alignment;\n  })).concat(_to_consumable_array(allowedPlacements.filter(function (placement) {\n    return getAlignment(placement) !== alignment;\n  }))) : allowedPlacements.filter(function (placement) {\n    return getSide(placement) === placement;\n  });\n  return allowedPlacementsSortedByAlignment.filter(function (placement) {\n    if (alignment) {\n      return getAlignment(placement) === alignment || (autoAlignment ? getOppositeAlignmentPlacement(placement) !== placement : false);\n    }\n    return true;\n  });\n}\n/**\n * Optimizes the visibility of the floating element by choosing the placement\n * that has the most space available automatically, without needing to specify a\n * preferred placement. Alternative to `flip`.\n * @see https://floating-ui.com/docs/autoPlacement\n */\nvar autoPlacement = function autoPlacement(options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: \"autoPlacement\",\n    options: options,\n    fn: function fn(state) {\n      return _async_to_generator(function () {\n        var _middlewareData$autoP, _middlewareData$autoP2, _placementsThatFitOnE, rects, middlewareData, placement, platform, elements, _evaluate, _evaluate_crossAxis, crossAxis, alignment, _evaluate_allowedPlacements, allowedPlacements, _evaluate_autoAlignment, autoAlignment, detectOverflowOptions, placements$1, overflow, currentIndex, currentPlacement, alignmentSides, _tmp, currentOverflows, allOverflows, nextPlacement, placementsSortedByMostSpace, placementsThatFitOnEachSide, resetPlacement;\n        return _ts_generator(this, function (_state) {\n          switch (_state.label) {\n            case 0:\n              rects = state.rects, middlewareData = state.middlewareData, placement = state.placement, platform = state.platform, elements = state.elements;\n              _evaluate = evaluate(options, state), _evaluate_crossAxis = _evaluate.crossAxis, crossAxis = _evaluate_crossAxis === void 0 ? false : _evaluate_crossAxis, alignment = _evaluate.alignment, _evaluate_allowedPlacements = _evaluate.allowedPlacements, allowedPlacements = _evaluate_allowedPlacements === void 0 ? placements : _evaluate_allowedPlacements, _evaluate_autoAlignment = _evaluate.autoAlignment, autoAlignment = _evaluate_autoAlignment === void 0 ? true : _evaluate_autoAlignment, detectOverflowOptions = _object_without_properties(_evaluate, [\"crossAxis\", \"alignment\", \"allowedPlacements\", \"autoAlignment\"]);\n              placements$1 = alignment !== undefined || allowedPlacements === placements ? getPlacementList(alignment || null, autoAlignment, allowedPlacements) : allowedPlacements;\n              return [4, detectOverflow(state, detectOverflowOptions)];\n            case 1:\n              overflow = _state.sent();\n              currentIndex = ((_middlewareData$autoP = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP.index) || 0;\n              currentPlacement = placements$1[currentIndex];\n              if (currentPlacement == null) {\n                return [2, {}];\n              }\n              _tmp = [currentPlacement, rects];\n              return [4, platform.isRTL == null ? void 0 : platform.isRTL(elements.floating)];\n            case 2:\n              alignmentSides = getAlignmentSides.apply(void 0, _tmp.concat([_state.sent()]));\n              // Make `computeCoords` start from the right place.\n              if (placement !== currentPlacement) {\n                return [2, {\n                  reset: {\n                    placement: placements$1[0]\n                  }\n                }];\n              }\n              currentOverflows = [overflow[getSide(currentPlacement)], overflow[alignmentSides[0]], overflow[alignmentSides[1]]];\n              allOverflows = _to_consumable_array(((_middlewareData$autoP2 = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP2.overflows) || []).concat([{\n                placement: currentPlacement,\n                overflows: currentOverflows\n              }]);\n              nextPlacement = placements$1[currentIndex + 1];\n              // There are more placements to check.\n              if (nextPlacement) {\n                return [2, {\n                  data: {\n                    index: currentIndex + 1,\n                    overflows: allOverflows\n                  },\n                  reset: {\n                    placement: nextPlacement\n                  }\n                }];\n              }\n              placementsSortedByMostSpace = allOverflows.map(function (d) {\n                var alignment = getAlignment(d.placement);\n                return [d.placement, alignment && crossAxis ?\n                // Check along the mainAxis and main crossAxis side.\n                d.overflows.slice(0, 2).reduce(function (acc, v) {\n                  return acc + v;\n                }, 0) :\n                // Check only the mainAxis.\n                d.overflows[0], d.overflows];\n              }).sort(function (a, b) {\n                return a[1] - b[1];\n              });\n              placementsThatFitOnEachSide = placementsSortedByMostSpace.filter(function (d) {\n                return d[2].slice(0,\n                // Aligned placements should not check their opposite crossAxis\n                // side.\n                getAlignment(d[0]) ? 2 : 3).every(function (v) {\n                  return v <= 0;\n                });\n              });\n              resetPlacement = ((_placementsThatFitOnE = placementsThatFitOnEachSide[0]) == null ? void 0 : _placementsThatFitOnE[0]) || placementsSortedByMostSpace[0][0];\n              if (resetPlacement !== placement) {\n                return [2, {\n                  data: {\n                    index: currentIndex + 1,\n                    overflows: allOverflows\n                  },\n                  reset: {\n                    placement: resetPlacement\n                  }\n                }];\n              }\n              return [2, {}];\n          }\n        });\n      })();\n    }\n  };\n};\n/**\n * Optimizes the visibility of the floating element by flipping the `placement`\n * in order to keep it in view when the preferred placement(s) will overflow the\n * clipping boundary. Alternative to `autoPlacement`.\n * @see https://floating-ui.com/docs/flip\n */\nvar flip = function flip(options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: \"flip\",\n    options: options,\n    fn: function fn(state) {\n      return _async_to_generator(function () {\n        var _middlewareData$arrow, _middlewareData$flip, placement, middlewareData, rects, initialPlacement, platform, elements, _evaluate, tmp, checkMainAxis, tmp1, checkCrossAxis, specifiedFallbackPlacements, _evaluate_fallbackStrategy, fallbackStrategy, _evaluate_fallbackAxisSideDirection, fallbackAxisSideDirection, _evaluate_flipAlignment, flipAlignment, detectOverflowOptions, side, isBasePlacement, rtl, fallbackPlacements, _fallbackPlacements, placements, overflow, overflows, overflowsData, sides, _middlewareData$flip2, _overflowsData$filter, nextIndex, nextPlacement, resetPlacement, _overflowsData$map$so, placement1;\n        return _ts_generator(this, function (_state) {\n          switch (_state.label) {\n            case 0:\n              placement = state.placement, middlewareData = state.middlewareData, rects = state.rects, initialPlacement = state.initialPlacement, platform = state.platform, elements = state.elements;\n              _evaluate = evaluate(options, state), tmp = _evaluate.mainAxis, checkMainAxis = tmp === void 0 ? true : tmp, tmp1 = _evaluate.crossAxis, checkCrossAxis = tmp1 === void 0 ? true : tmp1, specifiedFallbackPlacements = _evaluate.fallbackPlacements, _evaluate_fallbackStrategy = _evaluate.fallbackStrategy, fallbackStrategy = _evaluate_fallbackStrategy === void 0 ? \"bestFit\" : _evaluate_fallbackStrategy, _evaluate_fallbackAxisSideDirection = _evaluate.fallbackAxisSideDirection, fallbackAxisSideDirection = _evaluate_fallbackAxisSideDirection === void 0 ? \"none\" : _evaluate_fallbackAxisSideDirection, _evaluate_flipAlignment = _evaluate.flipAlignment, flipAlignment = _evaluate_flipAlignment === void 0 ? true : _evaluate_flipAlignment, detectOverflowOptions = _object_without_properties(_evaluate, [\"mainAxis\", \"crossAxis\", \"fallbackPlacements\", \"fallbackStrategy\", \"fallbackAxisSideDirection\", \"flipAlignment\"]);\n              // If a reset by the arrow was caused due to an alignment offset being\n              // added, we should skip any logic now since `flip()` has already done its\n              // work.\n              // https://github.com/floating-ui/floating-ui/issues/2549#issuecomment-1719601643\n              if ((_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {\n                return [2, {}];\n              }\n              side = getSide(placement);\n              isBasePlacement = getSide(initialPlacement) === initialPlacement;\n              return [4, platform.isRTL == null ? void 0 : platform.isRTL(elements.floating)];\n            case 1:\n              rtl = _state.sent();\n              fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));\n              if (!specifiedFallbackPlacements && fallbackAxisSideDirection !== \"none\") {\n                ;\n                (_fallbackPlacements = fallbackPlacements).push.apply(_fallbackPlacements, _to_consumable_array(getOppositeAxisPlacements(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl)));\n              }\n              placements = [initialPlacement].concat(_to_consumable_array(fallbackPlacements));\n              return [4, detectOverflow(state, detectOverflowOptions)];\n            case 2:\n              overflow = _state.sent();\n              overflows = [];\n              overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];\n              if (checkMainAxis) {\n                overflows.push(overflow[side]);\n              }\n              if (checkCrossAxis) {\n                sides = getAlignmentSides(placement, rects, rtl);\n                overflows.push(overflow[sides[0]], overflow[sides[1]]);\n              }\n              overflowsData = _to_consumable_array(overflowsData).concat([{\n                placement: placement,\n                overflows: overflows\n              }]);\n              // One or more sides is overflowing.\n              if (!overflows.every(function (side) {\n                return side <= 0;\n              })) {\n                ;\n                nextIndex = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1;\n                nextPlacement = placements[nextIndex];\n                if (nextPlacement) {\n                  // Try next placement and re-run the lifecycle.\n                  return [2, {\n                    data: {\n                      index: nextIndex,\n                      overflows: overflowsData\n                    },\n                    reset: {\n                      placement: nextPlacement\n                    }\n                  }];\n                }\n                // First, find the candidates that fit on the mainAxis side of overflow,\n                // then find the placement that fits the best on the main crossAxis side.\n                resetPlacement = (_overflowsData$filter = overflowsData.filter(function (d) {\n                  return d.overflows[0] <= 0;\n                }).sort(function (a, b) {\n                  return a.overflows[1] - b.overflows[1];\n                })[0]) == null ? void 0 : _overflowsData$filter.placement;\n                // Otherwise fallback.\n                if (!resetPlacement) {\n                  switch (fallbackStrategy) {\n                    case \"bestFit\":\n                      {\n                        ;\n                        placement1 = (_overflowsData$map$so = overflowsData.map(function (d) {\n                          return [d.placement, d.overflows.filter(function (overflow) {\n                            return overflow > 0;\n                          }).reduce(function (acc, overflow) {\n                            return acc + overflow;\n                          }, 0)];\n                        }).sort(function (a, b) {\n                          return a[1] - b[1];\n                        })[0]) == null ? void 0 : _overflowsData$map$so[0];\n                        if (placement1) {\n                          resetPlacement = placement1;\n                        }\n                        break;\n                      }\n                    case \"initialPlacement\":\n                      resetPlacement = initialPlacement;\n                      break;\n                  }\n                }\n                if (placement !== resetPlacement) {\n                  return [2, {\n                    reset: {\n                      placement: resetPlacement\n                    }\n                  }];\n                }\n              }\n              return [2, {}];\n          }\n        });\n      })();\n    }\n  };\n};\nfunction getSideOffsets(overflow, rect) {\n  return {\n    top: overflow.top - rect.height,\n    right: overflow.right - rect.width,\n    bottom: overflow.bottom - rect.height,\n    left: overflow.left - rect.width\n  };\n}\nfunction isAnySideFullyClipped(overflow) {\n  return sides.some(function (side) {\n    return overflow[side] >= 0;\n  });\n}\n/**\n * Provides data to hide the floating element in applicable situations, such as\n * when it is not in the same clipping context as the reference element.\n * @see https://floating-ui.com/docs/hide\n */\nvar hide = function hide(options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: \"hide\",\n    options: options,\n    fn: function fn(state) {\n      return _async_to_generator(function () {\n        var rects, _evaluate, _evaluate_strategy, strategy, detectOverflowOptions, overflow, offsets, overflow1, offsets1;\n        return _ts_generator(this, function (_state) {\n          switch (_state.label) {\n            case 0:\n              rects = state.rects;\n              _evaluate = evaluate(options, state), _evaluate_strategy = _evaluate.strategy, strategy = _evaluate_strategy === void 0 ? \"referenceHidden\" : _evaluate_strategy, detectOverflowOptions = _object_without_properties(_evaluate, [\"strategy\"]);\n              switch (strategy) {\n                case \"referenceHidden\":\n                  return [3, 1];\n                case \"escaped\":\n                  return [3, 3];\n              }\n              return [3, 5];\n            case 1:\n              return [4, detectOverflow(state, _object_spread_props(_object_spread({}, detectOverflowOptions), {\n                elementContext: \"reference\"\n              }))];\n            case 2:\n              overflow = _state.sent();\n              offsets = getSideOffsets(overflow, rects.reference);\n              return [2, {\n                data: {\n                  referenceHiddenOffsets: offsets,\n                  referenceHidden: isAnySideFullyClipped(offsets)\n                }\n              }];\n            case 3:\n              return [4, detectOverflow(state, _object_spread_props(_object_spread({}, detectOverflowOptions), {\n                altBoundary: true\n              }))];\n            case 4:\n              overflow1 = _state.sent();\n              offsets1 = getSideOffsets(overflow1, rects.floating);\n              return [2, {\n                data: {\n                  escapedOffsets: offsets1,\n                  escaped: isAnySideFullyClipped(offsets1)\n                }\n              }];\n            case 5:\n              {\n                return [2, {}];\n              }\n              _state.label = 6;\n            case 6:\n              return [2];\n          }\n        });\n      })();\n    }\n  };\n};\nfunction getBoundingRect(rects) {\n  var minX = min.apply(void 0, _to_consumable_array(rects.map(function (rect) {\n    return rect.left;\n  })));\n  var minY = min.apply(void 0, _to_consumable_array(rects.map(function (rect) {\n    return rect.top;\n  })));\n  var maxX = max.apply(void 0, _to_consumable_array(rects.map(function (rect) {\n    return rect.right;\n  })));\n  var maxY = max.apply(void 0, _to_consumable_array(rects.map(function (rect) {\n    return rect.bottom;\n  })));\n  return {\n    x: minX,\n    y: minY,\n    width: maxX - minX,\n    height: maxY - minY\n  };\n}\nfunction getRectsByLine(rects) {\n  var sortedRects = rects.slice().sort(function (a, b) {\n    return a.y - b.y;\n  });\n  var groups = [];\n  var prevRect = null;\n  for (var i = 0; i < sortedRects.length; i++) {\n    var rect = sortedRects[i];\n    if (!prevRect || rect.y - prevRect.y > prevRect.height / 2) {\n      groups.push([rect]);\n    } else {\n      groups[groups.length - 1].push(rect);\n    }\n    prevRect = rect;\n  }\n  return groups.map(function (rect) {\n    return rectToClientRect(getBoundingRect(rect));\n  });\n}\n/**\n * Provides improved positioning for inline reference elements that can span\n * over multiple lines, such as hyperlinks or range selections.\n * @see https://floating-ui.com/docs/inline\n */\nvar inline = function inline(options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: \"inline\",\n    options: options,\n    fn: function fn(state) {\n      return _async_to_generator(function () {\n        var placement, elements, rects, platform, strategy, _evaluate, _evaluate_padding, padding, x, y, nativeClientRects, _, clientRects, fallback, paddingObject, resetRects;\n        function getBoundingClientRect() {\n          // There are two rects and they are disjoined.\n          if (clientRects.length === 2 && clientRects[0].left > clientRects[1].right && x != null && y != null) {\n            // Find the first rect in which the point is fully inside.\n            return clientRects.find(function (rect) {\n              return x > rect.left - paddingObject.left && x < rect.right + paddingObject.right && y > rect.top - paddingObject.top && y < rect.bottom + paddingObject.bottom;\n            }) || fallback;\n          }\n          // There are 2 or more connected rects.\n          if (clientRects.length >= 2) {\n            if (getSideAxis(placement) === \"y\") {\n              var firstRect = clientRects[0];\n              var lastRect = clientRects[clientRects.length - 1];\n              var isTop = getSide(placement) === \"top\";\n              var top = firstRect.top;\n              var bottom = lastRect.bottom;\n              var left = isTop ? firstRect.left : lastRect.left;\n              var right = isTop ? firstRect.right : lastRect.right;\n              var width = right - left;\n              var height = bottom - top;\n              return {\n                top: top,\n                bottom: bottom,\n                left: left,\n                right: right,\n                width: width,\n                height: height,\n                x: left,\n                y: top\n              };\n            }\n            var isLeftSide = getSide(placement) === \"left\";\n            var maxRight = max.apply(void 0, _to_consumable_array(clientRects.map(function (rect) {\n              return rect.right;\n            })));\n            var minLeft = min.apply(void 0, _to_consumable_array(clientRects.map(function (rect) {\n              return rect.left;\n            })));\n            var measureRects = clientRects.filter(function (rect) {\n              return isLeftSide ? rect.left === minLeft : rect.right === maxRight;\n            });\n            var top1 = measureRects[0].top;\n            var bottom1 = measureRects[measureRects.length - 1].bottom;\n            var left1 = minLeft;\n            var right1 = maxRight;\n            var width1 = right1 - left1;\n            var height1 = bottom1 - top1;\n            return {\n              top: top1,\n              bottom: bottom1,\n              left: left1,\n              right: right1,\n              width: width1,\n              height: height1,\n              x: left1,\n              y: top1\n            };\n          }\n          return fallback;\n        }\n        return _ts_generator(this, function (_state) {\n          switch (_state.label) {\n            case 0:\n              placement = state.placement, elements = state.elements, rects = state.rects, platform = state.platform, strategy = state.strategy;\n              // A MouseEvent's client{X,Y} coords can be up to 2 pixels off a\n              // ClientRect's bounds, despite the event listener being triggered. A\n              // padding of 2 seems to handle this issue.\n              _evaluate = evaluate(options, state), _evaluate_padding = _evaluate.padding, padding = _evaluate_padding === void 0 ? 2 : _evaluate_padding, x = _evaluate.x, y = _evaluate.y;\n              _ = Array.from;\n              return [4, platform.getClientRects == null ? void 0 : platform.getClientRects(elements.reference)];\n            case 1:\n              nativeClientRects = _.apply(Array, [_state.sent() || []]);\n              clientRects = getRectsByLine(nativeClientRects);\n              fallback = rectToClientRect(getBoundingRect(nativeClientRects));\n              paddingObject = getPaddingObject(padding);\n              return [4, platform.getElementRects({\n                reference: {\n                  getBoundingClientRect: getBoundingClientRect\n                },\n                floating: elements.floating,\n                strategy: strategy\n              })];\n            case 2:\n              resetRects = _state.sent();\n              if (rects.reference.x !== resetRects.reference.x || rects.reference.y !== resetRects.reference.y || rects.reference.width !== resetRects.reference.width || rects.reference.height !== resetRects.reference.height) {\n                return [2, {\n                  reset: {\n                    rects: resetRects\n                  }\n                }];\n              }\n              return [2, {}];\n          }\n        });\n      })();\n    }\n  };\n};\nfunction convertValueToCoords(state, options) {\n  return _convertValueToCoords.apply(this, arguments);\n}\nfunction _convertValueToCoords() {\n  _convertValueToCoords =\n  // For type backwards-compatibility, the `OffsetOptions` type was also\n  // Derivable.\n  _async_to_generator(function (state, options) {\n    var placement, platform, elements, rtl, side, alignment, isVertical, mainAxisMulti, crossAxisMulti, rawValue, _ref, mainAxis, crossAxis, alignmentAxis;\n    return _ts_generator(this, function (_state) {\n      switch (_state.label) {\n        case 0:\n          placement = state.placement, platform = state.platform, elements = state.elements;\n          return [4, platform.isRTL == null ? void 0 : platform.isRTL(elements.floating)];\n        case 1:\n          rtl = _state.sent();\n          side = getSide(placement);\n          alignment = getAlignment(placement);\n          isVertical = getSideAxis(placement) === \"y\";\n          mainAxisMulti = [\"left\", \"top\"].includes(side) ? -1 : 1;\n          crossAxisMulti = rtl && isVertical ? -1 : 1;\n          rawValue = evaluate(options, state);\n          // eslint-disable-next-line prefer-const\n          _ref = typeof rawValue === \"number\" ? {\n            mainAxis: rawValue,\n            crossAxis: 0,\n            alignmentAxis: null\n          } : _object_spread({\n            mainAxis: 0,\n            crossAxis: 0,\n            alignmentAxis: null\n          }, rawValue), mainAxis = _ref.mainAxis, crossAxis = _ref.crossAxis, alignmentAxis = _ref.alignmentAxis;\n          if (alignment && typeof alignmentAxis === \"number\") {\n            crossAxis = alignment === \"end\" ? alignmentAxis * -1 : alignmentAxis;\n          }\n          return [2, isVertical ? {\n            x: crossAxis * crossAxisMulti,\n            y: mainAxis * mainAxisMulti\n          } : {\n            x: mainAxis * mainAxisMulti,\n            y: crossAxis * crossAxisMulti\n          }];\n      }\n    });\n  });\n  return _convertValueToCoords.apply(this, arguments);\n}\n/**\n * Modifies the placement by translating the floating element along the\n * specified axes.\n * A number (shorthand for `mainAxis` or distance), or an axes configuration\n * object may be passed.\n * @see https://floating-ui.com/docs/offset\n */\nvar offset = function offset(options) {\n  if (options === void 0) {\n    options = 0;\n  }\n  return {\n    name: \"offset\",\n    options: options,\n    fn: function fn(state) {\n      return _async_to_generator(function () {\n        var x, y, diffCoords;\n        return _ts_generator(this, function (_state) {\n          switch (_state.label) {\n            case 0:\n              x = state.x, y = state.y;\n              return [4, convertValueToCoords(state, options)];\n            case 1:\n              diffCoords = _state.sent();\n              return [2, {\n                x: x + diffCoords.x,\n                y: y + diffCoords.y,\n                data: diffCoords\n              }];\n          }\n        });\n      })();\n    }\n  };\n};\n/**\n * Optimizes the visibility of the floating element by shifting it in order to\n * keep it in view when it will overflow the clipping boundary.\n * @see https://floating-ui.com/docs/shift\n */\nvar shift = function shift(options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: \"shift\",\n    options: options,\n    fn: function fn(state) {\n      return _async_to_generator(function () {\n        var x, y, placement, _evaluate, tmp, checkMainAxis, tmp1, checkCrossAxis, _evaluate_limiter, limiter, detectOverflowOptions, coords, overflow, crossAxis, mainAxis, mainAxisCoord, crossAxisCoord, minSide, maxSide, min, max, minSide1, maxSide1, min1, max1, _obj, limitedCoords;\n        return _ts_generator(this, function (_state) {\n          switch (_state.label) {\n            case 0:\n              x = state.x, y = state.y, placement = state.placement;\n              _evaluate = evaluate(options, state), tmp = _evaluate.mainAxis, checkMainAxis = tmp === void 0 ? true : tmp, tmp1 = _evaluate.crossAxis, checkCrossAxis = tmp1 === void 0 ? false : tmp1, _evaluate_limiter = _evaluate.limiter, limiter = _evaluate_limiter === void 0 ? {\n                fn: function (_ref) {\n                  var x = _ref.x,\n                    y = _ref.y;\n                  return {\n                    x: x,\n                    y: y\n                  };\n                }\n              } : _evaluate_limiter, detectOverflowOptions = _object_without_properties(_evaluate, [\"mainAxis\", \"crossAxis\", \"limiter\"]);\n              coords = {\n                x: x,\n                y: y\n              };\n              return [4, detectOverflow(state, detectOverflowOptions)];\n            case 1:\n              overflow = _state.sent();\n              crossAxis = getSideAxis(getSide(placement));\n              mainAxis = getOppositeAxis(crossAxis);\n              mainAxisCoord = coords[mainAxis];\n              crossAxisCoord = coords[crossAxis];\n              if (checkMainAxis) {\n                minSide = mainAxis === \"y\" ? \"top\" : \"left\";\n                maxSide = mainAxis === \"y\" ? \"bottom\" : \"right\";\n                min = mainAxisCoord + overflow[minSide];\n                max = mainAxisCoord - overflow[maxSide];\n                mainAxisCoord = clamp(min, mainAxisCoord, max);\n              }\n              if (checkCrossAxis) {\n                minSide1 = crossAxis === \"y\" ? \"top\" : \"left\";\n                maxSide1 = crossAxis === \"y\" ? \"bottom\" : \"right\";\n                min1 = crossAxisCoord + overflow[minSide1];\n                max1 = crossAxisCoord - overflow[maxSide1];\n                crossAxisCoord = clamp(min1, crossAxisCoord, max1);\n              }\n              limitedCoords = limiter.fn(_object_spread_props(_object_spread({}, state), (_obj = {}, _define_property(_obj, mainAxis, mainAxisCoord), _define_property(_obj, crossAxis, crossAxisCoord), _obj)));\n              return [2, _object_spread_props(_object_spread({}, limitedCoords), {\n                data: {\n                  x: limitedCoords.x - x,\n                  y: limitedCoords.y - y\n                }\n              })];\n          }\n        });\n      })();\n    }\n  };\n};\n/**\n * Built-in `limiter` that will stop `shift()` at a certain point.\n */\nvar limitShift = function limitShift(options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    options: options,\n    fn: function fn(state) {\n      var x = state.x,\n        y = state.y,\n        placement = state.placement,\n        rects = state.rects,\n        middlewareData = state.middlewareData;\n      var _evaluate = evaluate(options, state),\n        _evaluate_offset = _evaluate.offset,\n        offset = _evaluate_offset === void 0 ? 0 : _evaluate_offset,\n        tmp = _evaluate.mainAxis,\n        checkMainAxis = tmp === void 0 ? true : tmp,\n        tmp1 = _evaluate.crossAxis,\n        checkCrossAxis = tmp1 === void 0 ? true : tmp1;\n      var coords = {\n        x: x,\n        y: y\n      };\n      var crossAxis = getSideAxis(placement);\n      var mainAxis = getOppositeAxis(crossAxis);\n      var mainAxisCoord = coords[mainAxis];\n      var crossAxisCoord = coords[crossAxis];\n      var rawOffset = evaluate(offset, state);\n      var computedOffset = typeof rawOffset === \"number\" ? {\n        mainAxis: rawOffset,\n        crossAxis: 0\n      } : _object_spread({\n        mainAxis: 0,\n        crossAxis: 0\n      }, rawOffset);\n      if (checkMainAxis) {\n        var len = mainAxis === \"y\" ? \"height\" : \"width\";\n        var limitMin = rects.reference[mainAxis] - rects.floating[len] + computedOffset.mainAxis;\n        var limitMax = rects.reference[mainAxis] + rects.reference[len] - computedOffset.mainAxis;\n        if (mainAxisCoord < limitMin) {\n          mainAxisCoord = limitMin;\n        } else if (mainAxisCoord > limitMax) {\n          mainAxisCoord = limitMax;\n        }\n      }\n      if (checkCrossAxis) {\n        var _middlewareData$offse, _middlewareData$offse2;\n        var len1 = mainAxis === \"y\" ? \"width\" : \"height\";\n        var isOriginSide = [\"top\", \"left\"].includes(getSide(placement));\n        var limitMin1 = rects.reference[crossAxis] - rects.floating[len1] + (isOriginSide ? ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse[crossAxis]) || 0 : 0) + (isOriginSide ? 0 : computedOffset.crossAxis);\n        var limitMax1 = rects.reference[crossAxis] + rects.reference[len1] + (isOriginSide ? 0 : ((_middlewareData$offse2 = middlewareData.offset) == null ? void 0 : _middlewareData$offse2[crossAxis]) || 0) - (isOriginSide ? computedOffset.crossAxis : 0);\n        if (crossAxisCoord < limitMin1) {\n          crossAxisCoord = limitMin1;\n        } else if (crossAxisCoord > limitMax1) {\n          crossAxisCoord = limitMax1;\n        }\n      }\n      var _obj;\n      return _obj = {}, _define_property(_obj, mainAxis, mainAxisCoord), _define_property(_obj, crossAxis, crossAxisCoord), _obj;\n    }\n  };\n};\n/**\n * Provides data that allows you to change the size of the floating element —\n * for instance, prevent it from overflowing the clipping boundary or match the\n * width of the reference element.\n * @see https://floating-ui.com/docs/size\n */\nvar size = function size(options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: \"size\",\n    options: options,\n    fn: function fn(state) {\n      return _async_to_generator(function () {\n        var placement, rects, platform, elements, _evaluate, _evaluate_apply, apply, detectOverflowOptions, overflow, side, alignment, isYAxis, _rects_floating, width, height, heightSide, widthSide, overflowAvailableHeight, overflowAvailableWidth, noShift, availableHeight, availableWidth, maximumClippingWidth, maximumClippingHeight, xMin, xMax, yMin, yMax, nextDimensions;\n        return _ts_generator(this, function (_state) {\n          switch (_state.label) {\n            case 0:\n              placement = state.placement, rects = state.rects, platform = state.platform, elements = state.elements;\n              _evaluate = evaluate(options, state), _evaluate_apply = _evaluate.apply, apply = _evaluate_apply === void 0 ? function () {} : _evaluate_apply, detectOverflowOptions = _object_without_properties(_evaluate, [\"apply\"]);\n              return [4, detectOverflow(state, detectOverflowOptions)];\n            case 1:\n              overflow = _state.sent();\n              side = getSide(placement);\n              alignment = getAlignment(placement);\n              isYAxis = getSideAxis(placement) === \"y\";\n              _rects_floating = rects.floating, width = _rects_floating.width, height = _rects_floating.height;\n              if (!(side === \"top\" || side === \"bottom\")) return [3, 3];\n              heightSide = side;\n              return [4, platform.isRTL == null ? void 0 : platform.isRTL(elements.floating)];\n            case 2:\n              widthSide = alignment === (_state.sent() ? \"start\" : \"end\") ? \"left\" : \"right\";\n              return [3, 4];\n            case 3:\n              widthSide = side;\n              heightSide = alignment === \"end\" ? \"top\" : \"bottom\";\n              _state.label = 4;\n            case 4:\n              overflowAvailableHeight = height - overflow[heightSide];\n              overflowAvailableWidth = width - overflow[widthSide];\n              noShift = !state.middlewareData.shift;\n              availableHeight = overflowAvailableHeight;\n              availableWidth = overflowAvailableWidth;\n              if (isYAxis) {\n                maximumClippingWidth = width - overflow.left - overflow.right;\n                availableWidth = alignment || noShift ? min(overflowAvailableWidth, maximumClippingWidth) : maximumClippingWidth;\n              } else {\n                maximumClippingHeight = height - overflow.top - overflow.bottom;\n                availableHeight = alignment || noShift ? min(overflowAvailableHeight, maximumClippingHeight) : maximumClippingHeight;\n              }\n              if (noShift && !alignment) {\n                xMin = max(overflow.left, 0);\n                xMax = max(overflow.right, 0);\n                yMin = max(overflow.top, 0);\n                yMax = max(overflow.bottom, 0);\n                if (isYAxis) {\n                  availableWidth = width - 2 * (xMin !== 0 || xMax !== 0 ? xMin + xMax : max(overflow.left, overflow.right));\n                } else {\n                  availableHeight = height - 2 * (yMin !== 0 || yMax !== 0 ? yMin + yMax : max(overflow.top, overflow.bottom));\n                }\n              }\n              return [4, apply(_object_spread_props(_object_spread({}, state), {\n                availableWidth: availableWidth,\n                availableHeight: availableHeight\n              }))];\n            case 5:\n              _state.sent();\n              return [4, platform.getDimensions(elements.floating)];\n            case 6:\n              nextDimensions = _state.sent();\n              if (width !== nextDimensions.width || height !== nextDimensions.height) {\n                return [2, {\n                  reset: {\n                    rects: true\n                  }\n                }];\n              }\n              return [2, {}];\n          }\n        });\n      })();\n    }\n  };\n};\nexport { arrow, autoPlacement, computePosition, detectOverflow, flip, hide, inline, limitShift, offset, shift, size };","map":{"version":3,"names":["_","_async_to_generator","_define_property","_object_spread","_object_spread_props","_object_without_properties","_to_consumable_array","_ts_generator","getSideAxis","getAlignmentAxis","getAxisLength","getSide","getAlignment","evaluate","getPaddingObject","rectToClientRect","min","clamp","placements","getAlignmentSides","getOppositeAlignmentPlacement","getOppositePlacement","getExpandedPlacements","getOppositeAxisPlacements","sides","max","getOppositeAxis","computeCoordsFromPlacement","_ref","placement","rtl","reference","floating","sideAxis","alignmentAxis","alignLength","side","isVertical","commonX","x","width","commonY","y","height","commonAlign","coords","computePosition","config","_config_placement","_config_strategy","strategy","_config_middleware","middleware","platform","validMiddleware","rects","_computeCoordsFromPlacement","statefulPlacement","middlewareData","resetCount","i","_validMiddleware_i","name","fn","nextX","nextY","data","reset","_tmp","ref","_state","label","filter","Boolean","isRTL","sent","getElementRects","length","initialPlacement","elements","apply","arguments","detectOverflow","state","options","_detectOverflow","_await$platform$isEle","_evaluate","_evaluate_boundary","boundary","_evaluate_rootBoundary","rootBoundary","_evaluate_elementContext","elementContext","_evaluate_altBoundary","altBoundary","_evaluate_padding","padding","paddingObject","altContext","element","clippingClientRect","_tmp1","_tmp2","rect","offsetParent","offsetScale","_tmp3","elementClientRect","_tmp4","getClippingRect","isElement","contextElement","getDocumentElement","getOffsetParent","getScale","convertOffsetParentRelativeRectToViewportRelativeRect","top","bottom","left","right","arrow","_ref_padding","axis","arrowDimensions","isYAxis","minProp","maxProp","clientProp","endDiff","startDiff","arrowOffsetParent","clientSize","centerToReference","largestPossiblePadding","minPadding","maxPadding","min$1","center","offset","shouldAddOffset","alignmentOffset","_obj","_obj1","getDimensions","getPlacementList","alignment","autoAlignment","allowedPlacements","allowedPlacementsSortedByAlignment","concat","autoPlacement","_middlewareData$autoP","_middlewareData$autoP2","_placementsThatFitOnE","_evaluate_crossAxis","crossAxis","_evaluate_allowedPlacements","_evaluate_autoAlignment","detectOverflowOptions","placements$1","overflow","currentIndex","currentPlacement","alignmentSides","currentOverflows","allOverflows","nextPlacement","placementsSortedByMostSpace","placementsThatFitOnEachSide","resetPlacement","undefined","index","overflows","map","d","slice","reduce","acc","v","sort","a","b","every","flip","_middlewareData$arrow","_middlewareData$flip","tmp","checkMainAxis","tmp1","checkCrossAxis","specifiedFallbackPlacements","_evaluate_fallbackStrategy","fallbackStrategy","_evaluate_fallbackAxisSideDirection","fallbackAxisSideDirection","_evaluate_flipAlignment","flipAlignment","isBasePlacement","fallbackPlacements","_fallbackPlacements","overflowsData","_middlewareData$flip2","_overflowsData$filter","nextIndex","_overflowsData$map$so","placement1","mainAxis","push","getSideOffsets","isAnySideFullyClipped","some","hide","_evaluate_strategy","offsets","overflow1","offsets1","referenceHiddenOffsets","referenceHidden","escapedOffsets","escaped","getBoundingRect","minX","minY","maxX","maxY","getRectsByLine","sortedRects","groups","prevRect","inline","nativeClientRects","clientRects","fallback","resetRects","getBoundingClientRect","find","firstRect","lastRect","isTop","isLeftSide","maxRight","minLeft","measureRects","top1","bottom1","left1","right1","width1","height1","Array","from","getClientRects","convertValueToCoords","_convertValueToCoords","mainAxisMulti","crossAxisMulti","rawValue","includes","diffCoords","shift","_evaluate_limiter","limiter","mainAxisCoord","crossAxisCoord","minSide","maxSide","minSide1","maxSide1","min1","max1","limitedCoords","limitShift","_evaluate_offset","rawOffset","computedOffset","len","limitMin","limitMax","_middlewareData$offse","_middlewareData$offse2","len1","isOriginSide","limitMin1","limitMax1","size","_evaluate_apply","_rects_floating","heightSide","widthSide","overflowAvailableHeight","overflowAvailableWidth","noShift","availableHeight","availableWidth","maximumClippingWidth","maximumClippingHeight","xMin","xMax","yMin","yMax","nextDimensions"],"sources":["/Users/mirustal/Documents/project/rooms/front/rooms/node_modules/@vkontakte/vkui-floating-ui/core/dist/floating-ui.core.esm.js"],"sourcesContent":["import { _ as _async_to_generator } from \"@swc/helpers/_/_async_to_generator\";\nimport { _ as _define_property } from \"@swc/helpers/_/_define_property\";\nimport { _ as _object_spread } from \"@swc/helpers/_/_object_spread\";\nimport { _ as _object_spread_props } from \"@swc/helpers/_/_object_spread_props\";\nimport { _ as _object_without_properties } from \"@swc/helpers/_/_object_without_properties\";\nimport { _ as _to_consumable_array } from \"@swc/helpers/_/_to_consumable_array\";\nimport { _ as _ts_generator } from \"@swc/helpers/_/_ts_generator\";\nimport { getSideAxis, getAlignmentAxis, getAxisLength, getSide, getAlignment, evaluate, getPaddingObject, rectToClientRect, min, clamp, placements, getAlignmentSides, getOppositeAlignmentPlacement, getOppositePlacement, getExpandedPlacements, getOppositeAxisPlacements, sides, max, getOppositeAxis } from '../../utils/dist/floating-ui.utils.esm.js';\nexport { rectToClientRect } from '../../utils/dist/floating-ui.utils.esm.js';\nfunction computeCoordsFromPlacement(_ref, placement, rtl) {\n    var reference = _ref.reference, floating = _ref.floating;\n    var sideAxis = getSideAxis(placement);\n    var alignmentAxis = getAlignmentAxis(placement);\n    var alignLength = getAxisLength(alignmentAxis);\n    var side = getSide(placement);\n    var isVertical = sideAxis === \"y\";\n    var commonX = reference.x + reference.width / 2 - floating.width / 2;\n    var commonY = reference.y + reference.height / 2 - floating.height / 2;\n    var commonAlign = reference[alignLength] / 2 - floating[alignLength] / 2;\n    var coords;\n    switch(side){\n        case \"top\":\n            coords = {\n                x: commonX,\n                y: reference.y - floating.height\n            };\n            break;\n        case \"bottom\":\n            coords = {\n                x: commonX,\n                y: reference.y + reference.height\n            };\n            break;\n        case \"right\":\n            coords = {\n                x: reference.x + reference.width,\n                y: commonY\n            };\n            break;\n        case \"left\":\n            coords = {\n                x: reference.x - floating.width,\n                y: commonY\n            };\n            break;\n        default:\n            coords = {\n                x: reference.x,\n                y: reference.y\n            };\n    }\n    switch(getAlignment(placement)){\n        case \"start\":\n            coords[alignmentAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);\n            break;\n        case \"end\":\n            coords[alignmentAxis] += commonAlign * (rtl && isVertical ? -1 : 1);\n            break;\n    }\n    return coords;\n}\n/**\n * Computes the `x` and `y` coordinates that will place the floating element\n * next to a reference element when it is given a certain positioning strategy.\n *\n * This export does not have any `platform` interface logic. You will need to\n * write one for the platform you are using Floating UI with.\n */ var computePosition = function() {\n    var _ref = _async_to_generator(function(reference, floating, config) {\n        var _config_placement, placement, _config_strategy, strategy, _config_middleware, middleware, platform, validMiddleware, rtl, rects, _computeCoordsFromPlacement, x, y, statefulPlacement, middlewareData, resetCount, i, _validMiddleware_i, name, fn, _ref, nextX, nextY, data, reset, _tmp, ref;\n        return _ts_generator(this, function(_state) {\n            switch(_state.label){\n                case 0:\n                    _config_placement = config.placement, placement = _config_placement === void 0 ? \"bottom\" : _config_placement, _config_strategy = config.strategy, strategy = _config_strategy === void 0 ? \"absolute\" : _config_strategy, _config_middleware = config.middleware, middleware = _config_middleware === void 0 ? [] : _config_middleware, platform = config.platform;\n                    validMiddleware = middleware.filter(Boolean);\n                    return [\n                        4,\n                        platform.isRTL == null ? void 0 : platform.isRTL(floating)\n                    ];\n                case 1:\n                    rtl = _state.sent();\n                    return [\n                        4,\n                        platform.getElementRects({\n                            reference: reference,\n                            floating: floating,\n                            strategy: strategy\n                        })\n                    ];\n                case 2:\n                    rects = _state.sent();\n                    _computeCoordsFromPlacement = computeCoordsFromPlacement(rects, placement, rtl), x = _computeCoordsFromPlacement.x, y = _computeCoordsFromPlacement.y;\n                    statefulPlacement = placement;\n                    middlewareData = {};\n                    resetCount = 0;\n                    i = 0;\n                    _state.label = 3;\n                case 3:\n                    if (!(i < validMiddleware.length)) return [\n                        3,\n                        11\n                    ];\n                    _validMiddleware_i = validMiddleware[i], name = _validMiddleware_i.name, fn = _validMiddleware_i.fn;\n                    return [\n                        4,\n                        fn({\n                            x: x,\n                            y: y,\n                            initialPlacement: placement,\n                            placement: statefulPlacement,\n                            strategy: strategy,\n                            middlewareData: middlewareData,\n                            rects: rects,\n                            platform: platform,\n                            elements: {\n                                reference: reference,\n                                floating: floating\n                            }\n                        })\n                    ];\n                case 4:\n                    _ref = _state.sent(), nextX = _ref.x, nextY = _ref.y, data = _ref.data, reset = _ref.reset;\n                    x = nextX != null ? nextX : x;\n                    y = nextY != null ? nextY : y;\n                    middlewareData = _object_spread_props(_object_spread({}, middlewareData), _define_property({}, name, _object_spread({}, middlewareData[name], data)));\n                    if (!(reset && resetCount <= 50)) return [\n                        3,\n                        10\n                    ];\n                    resetCount++;\n                    if (!(typeof reset === \"object\")) return [\n                        3,\n                        9\n                    ];\n                    if (reset.placement) {\n                        statefulPlacement = reset.placement;\n                    }\n                    if (!reset.rects) return [\n                        3,\n                        8\n                    ];\n                    if (!(reset.rects === true)) return [\n                        3,\n                        6\n                    ];\n                    return [\n                        4,\n                        platform.getElementRects({\n                            reference: reference,\n                            floating: floating,\n                            strategy: strategy\n                        })\n                    ];\n                case 5:\n                    _tmp = _state.sent();\n                    return [\n                        3,\n                        7\n                    ];\n                case 6:\n                    _tmp = reset.rects;\n                    _state.label = 7;\n                case 7:\n                    rects = _tmp;\n                    _state.label = 8;\n                case 8:\n                    ref = computeCoordsFromPlacement(rects, statefulPlacement, rtl), x = ref.x, y = ref.y, ref;\n                    _state.label = 9;\n                case 9:\n                    i = -1;\n                    return [\n                        3,\n                        10\n                    ];\n                case 10:\n                    i++;\n                    return [\n                        3,\n                        3\n                    ];\n                case 11:\n                    return [\n                        2,\n                        {\n                            x: x,\n                            y: y,\n                            placement: statefulPlacement,\n                            strategy: strategy,\n                            middlewareData: middlewareData\n                        }\n                    ];\n            }\n        });\n    });\n    return function computePosition(reference, floating, config) {\n        return _ref.apply(this, arguments);\n    };\n}();\nfunction detectOverflow(state, options) {\n    return _detectOverflow.apply(this, arguments);\n}\nfunction _detectOverflow() {\n    _detectOverflow = /**\n * Resolves with an object of overflow side offsets that determine how much the\n * element is overflowing a given clipping boundary on each side.\n * - positive = overflowing the boundary by that number of pixels\n * - negative = how many pixels left before it will overflow\n * - 0 = lies flush with the boundary\n * @see https://floating-ui.com/docs/detectOverflow\n */ _async_to_generator(function(state, options) {\n        var _await$platform$isEle, x, y, platform, rects, elements, strategy, _evaluate, _evaluate_boundary, boundary, _evaluate_rootBoundary, rootBoundary, _evaluate_elementContext, elementContext, _evaluate_altBoundary, altBoundary, _evaluate_padding, padding, paddingObject, altContext, element, clippingClientRect, _, _tmp, _tmp1, _tmp2, rect, offsetParent, offsetScale, _tmp3, elementClientRect, _tmp4;\n        return _ts_generator(this, function(_state) {\n            switch(_state.label){\n                case 0:\n                    if (options === void 0) {\n                        options = {};\n                    }\n                    x = state.x, y = state.y, platform = state.platform, rects = state.rects, elements = state.elements, strategy = state.strategy;\n                    _evaluate = evaluate(options, state), _evaluate_boundary = _evaluate.boundary, boundary = _evaluate_boundary === void 0 ? \"clippingAncestors\" : _evaluate_boundary, _evaluate_rootBoundary = _evaluate.rootBoundary, rootBoundary = _evaluate_rootBoundary === void 0 ? \"viewport\" : _evaluate_rootBoundary, _evaluate_elementContext = _evaluate.elementContext, elementContext = _evaluate_elementContext === void 0 ? \"floating\" : _evaluate_elementContext, _evaluate_altBoundary = _evaluate.altBoundary, altBoundary = _evaluate_altBoundary === void 0 ? false : _evaluate_altBoundary, _evaluate_padding = _evaluate.padding, padding = _evaluate_padding === void 0 ? 0 : _evaluate_padding;\n                    paddingObject = getPaddingObject(padding);\n                    altContext = elementContext === \"floating\" ? \"reference\" : \"floating\";\n                    element = elements[altBoundary ? altContext : elementContext];\n                    _ = platform.getClippingRect;\n                    _tmp = {};\n                    return [\n                        4,\n                        platform.isElement == null ? void 0 : platform.isElement(element)\n                    ];\n                case 1:\n                    if (!((_await$platform$isEle = _state.sent()) != null ? _await$platform$isEle : true)) return [\n                        3,\n                        2\n                    ];\n                    _tmp1 = element;\n                    return [\n                        3,\n                        5\n                    ];\n                case 2:\n                    _tmp2 = element.contextElement;\n                    if (_tmp2) return [\n                        3,\n                        4\n                    ];\n                    return [\n                        4,\n                        platform.getDocumentElement == null ? void 0 : platform.getDocumentElement(elements.floating)\n                    ];\n                case 3:\n                    _tmp2 = _state.sent();\n                    _state.label = 4;\n                case 4:\n                    _tmp1 = _tmp2;\n                    _state.label = 5;\n                case 5:\n                    return [\n                        4,\n                        _.apply(platform, [\n                            (_tmp.element = _tmp1, _tmp.boundary = boundary, _tmp.rootBoundary = rootBoundary, _tmp.strategy = strategy, _tmp)\n                        ])\n                    ];\n                case 6:\n                    clippingClientRect = rectToClientRect.apply(void 0, [\n                        _state.sent()\n                    ]);\n                    rect = elementContext === \"floating\" ? _object_spread_props(_object_spread({}, rects.floating), {\n                        x: x,\n                        y: y\n                    }) : rects.reference;\n                    return [\n                        4,\n                        platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(elements.floating)\n                    ];\n                case 7:\n                    offsetParent = _state.sent();\n                    return [\n                        4,\n                        platform.isElement == null ? void 0 : platform.isElement(offsetParent)\n                    ];\n                case 8:\n                    if (!_state.sent()) return [\n                        3,\n                        10\n                    ];\n                    return [\n                        4,\n                        platform.getScale == null ? void 0 : platform.getScale(offsetParent)\n                    ];\n                case 9:\n                    _tmp3 = _state.sent() || {\n                        x: 1,\n                        y: 1\n                    };\n                    return [\n                        3,\n                        11\n                    ];\n                case 10:\n                    _tmp3 = {\n                        x: 1,\n                        y: 1\n                    };\n                    _state.label = 11;\n                case 11:\n                    offsetScale = _tmp3;\n                    if (!platform.convertOffsetParentRelativeRectToViewportRelativeRect) return [\n                        3,\n                        13\n                    ];\n                    return [\n                        4,\n                        platform.convertOffsetParentRelativeRectToViewportRelativeRect({\n                            rect: rect,\n                            offsetParent: offsetParent,\n                            strategy: strategy\n                        })\n                    ];\n                case 12:\n                    _tmp4 = _state.sent();\n                    return [\n                        3,\n                        14\n                    ];\n                case 13:\n                    _tmp4 = rect;\n                    _state.label = 14;\n                case 14:\n                    elementClientRect = rectToClientRect.apply(void 0, [\n                        _tmp4\n                    ]);\n                    return [\n                        2,\n                        {\n                            top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,\n                            bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,\n                            left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,\n                            right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x\n                        }\n                    ];\n            }\n        });\n    });\n    return _detectOverflow.apply(this, arguments);\n}\n/**\n * Provides data to position an inner element of the floating element so that it\n * appears centered to the reference element.\n * @see https://floating-ui.com/docs/arrow\n */ var arrow = function(options) {\n    return {\n        name: \"arrow\",\n        options: options,\n        fn: function fn(state) {\n            return _async_to_generator(function() {\n                var x, y, placement, rects, platform, elements, middlewareData, _ref, element, _ref_padding, padding, paddingObject, coords, axis, length, arrowDimensions, isYAxis, minProp, maxProp, clientProp, endDiff, startDiff, arrowOffsetParent, clientSize, _tmp, centerToReference, largestPossiblePadding, minPadding, maxPadding, min$1, max, center, offset, shouldAddOffset, alignmentOffset, _obj, _obj1;\n                return _ts_generator(this, function(_state) {\n                    switch(_state.label){\n                        case 0:\n                            x = state.x, y = state.y, placement = state.placement, rects = state.rects, platform = state.platform, elements = state.elements, middlewareData = state.middlewareData;\n                            // Since `element` is required, we don't Partial<> the type.\n                            _ref = evaluate(options, state) || {}, element = _ref.element, _ref_padding = _ref.padding, padding = _ref_padding === void 0 ? 0 : _ref_padding;\n                            if (element == null) {\n                                return [\n                                    2,\n                                    {}\n                                ];\n                            }\n                            paddingObject = getPaddingObject(padding);\n                            coords = {\n                                x: x,\n                                y: y\n                            };\n                            axis = getAlignmentAxis(placement);\n                            length = getAxisLength(axis);\n                            return [\n                                4,\n                                platform.getDimensions(element)\n                            ];\n                        case 1:\n                            arrowDimensions = _state.sent();\n                            isYAxis = axis === \"y\";\n                            minProp = isYAxis ? \"top\" : \"left\";\n                            maxProp = isYAxis ? \"bottom\" : \"right\";\n                            clientProp = isYAxis ? \"clientHeight\" : \"clientWidth\";\n                            endDiff = rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length];\n                            startDiff = coords[axis] - rects.reference[axis];\n                            return [\n                                4,\n                                platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(element)\n                            ];\n                        case 2:\n                            arrowOffsetParent = _state.sent();\n                            clientSize = arrowOffsetParent ? arrowOffsetParent[clientProp] : 0;\n                            _tmp = !clientSize;\n                            if (_tmp) return [\n                                3,\n                                4\n                            ];\n                            return [\n                                4,\n                                platform.isElement == null ? void 0 : platform.isElement(arrowOffsetParent)\n                            ];\n                        case 3:\n                            _tmp = !_state.sent();\n                            _state.label = 4;\n                        case 4:\n                            // DOM platform can return `window` as the `offsetParent`.\n                            if (_tmp) {\n                                clientSize = elements.floating[clientProp] || rects.floating[length];\n                            }\n                            centerToReference = endDiff / 2 - startDiff / 2;\n                            // If the padding is large enough that it causes the arrow to no longer be\n                            // centered, modify the padding so that it is centered.\n                            largestPossiblePadding = clientSize / 2 - arrowDimensions[length] / 2 - 1;\n                            minPadding = min(paddingObject[minProp], largestPossiblePadding);\n                            maxPadding = min(paddingObject[maxProp], largestPossiblePadding);\n                            // Make sure the arrow doesn't overflow the floating element if the center\n                            // point is outside the floating element's bounds.\n                            min$1 = minPadding;\n                            max = clientSize - arrowDimensions[length] - maxPadding;\n                            center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;\n                            offset = clamp(min$1, center, max);\n                            // If the reference is small enough that the arrow's padding causes it to\n                            // to point to nothing for an aligned placement, adjust the offset of the\n                            // floating element itself. To ensure `shift()` continues to take action,\n                            // a single reset is performed when this is true.\n                            shouldAddOffset = !middlewareData.arrow && getAlignment(placement) != null && center != offset && rects.reference[length] / 2 - (center < min$1 ? minPadding : maxPadding) - arrowDimensions[length] / 2 < 0;\n                            alignmentOffset = shouldAddOffset ? center < min$1 ? center - min$1 : center - max : 0;\n                            return [\n                                2,\n                                (_obj1 = {}, _define_property(_obj1, axis, coords[axis] + alignmentOffset), _define_property(_obj1, \"data\", _object_spread((_obj = {}, _define_property(_obj, axis, offset), _define_property(_obj, \"centerOffset\", center - offset - alignmentOffset), _obj), shouldAddOffset && {\n                                    alignmentOffset: alignmentOffset\n                                })), _define_property(_obj1, \"reset\", shouldAddOffset), _obj1)\n                            ];\n                    }\n                });\n            })();\n        }\n    };\n};\nfunction getPlacementList(alignment, autoAlignment, allowedPlacements) {\n    var allowedPlacementsSortedByAlignment = alignment ? _to_consumable_array(allowedPlacements.filter(function(placement) {\n        return getAlignment(placement) === alignment;\n    })).concat(_to_consumable_array(allowedPlacements.filter(function(placement) {\n        return getAlignment(placement) !== alignment;\n    }))) : allowedPlacements.filter(function(placement) {\n        return getSide(placement) === placement;\n    });\n    return allowedPlacementsSortedByAlignment.filter(function(placement) {\n        if (alignment) {\n            return getAlignment(placement) === alignment || (autoAlignment ? getOppositeAlignmentPlacement(placement) !== placement : false);\n        }\n        return true;\n    });\n}\n/**\n * Optimizes the visibility of the floating element by choosing the placement\n * that has the most space available automatically, without needing to specify a\n * preferred placement. Alternative to `flip`.\n * @see https://floating-ui.com/docs/autoPlacement\n */ var autoPlacement = function autoPlacement(options) {\n    if (options === void 0) {\n        options = {};\n    }\n    return {\n        name: \"autoPlacement\",\n        options: options,\n        fn: function fn(state) {\n            return _async_to_generator(function() {\n                var _middlewareData$autoP, _middlewareData$autoP2, _placementsThatFitOnE, rects, middlewareData, placement, platform, elements, _evaluate, _evaluate_crossAxis, crossAxis, alignment, _evaluate_allowedPlacements, allowedPlacements, _evaluate_autoAlignment, autoAlignment, detectOverflowOptions, placements$1, overflow, currentIndex, currentPlacement, alignmentSides, _tmp, currentOverflows, allOverflows, nextPlacement, placementsSortedByMostSpace, placementsThatFitOnEachSide, resetPlacement;\n                return _ts_generator(this, function(_state) {\n                    switch(_state.label){\n                        case 0:\n                            rects = state.rects, middlewareData = state.middlewareData, placement = state.placement, platform = state.platform, elements = state.elements;\n                            _evaluate = evaluate(options, state), _evaluate_crossAxis = _evaluate.crossAxis, crossAxis = _evaluate_crossAxis === void 0 ? false : _evaluate_crossAxis, alignment = _evaluate.alignment, _evaluate_allowedPlacements = _evaluate.allowedPlacements, allowedPlacements = _evaluate_allowedPlacements === void 0 ? placements : _evaluate_allowedPlacements, _evaluate_autoAlignment = _evaluate.autoAlignment, autoAlignment = _evaluate_autoAlignment === void 0 ? true : _evaluate_autoAlignment, detectOverflowOptions = _object_without_properties(_evaluate, [\n                                \"crossAxis\",\n                                \"alignment\",\n                                \"allowedPlacements\",\n                                \"autoAlignment\"\n                            ]);\n                            placements$1 = alignment !== undefined || allowedPlacements === placements ? getPlacementList(alignment || null, autoAlignment, allowedPlacements) : allowedPlacements;\n                            return [\n                                4,\n                                detectOverflow(state, detectOverflowOptions)\n                            ];\n                        case 1:\n                            overflow = _state.sent();\n                            currentIndex = ((_middlewareData$autoP = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP.index) || 0;\n                            currentPlacement = placements$1[currentIndex];\n                            if (currentPlacement == null) {\n                                return [\n                                    2,\n                                    {}\n                                ];\n                            }\n                            _tmp = [\n                                currentPlacement,\n                                rects\n                            ];\n                            return [\n                                4,\n                                platform.isRTL == null ? void 0 : platform.isRTL(elements.floating)\n                            ];\n                        case 2:\n                            alignmentSides = getAlignmentSides.apply(void 0, _tmp.concat([\n                                _state.sent()\n                            ]));\n                            // Make `computeCoords` start from the right place.\n                            if (placement !== currentPlacement) {\n                                return [\n                                    2,\n                                    {\n                                        reset: {\n                                            placement: placements$1[0]\n                                        }\n                                    }\n                                ];\n                            }\n                            currentOverflows = [\n                                overflow[getSide(currentPlacement)],\n                                overflow[alignmentSides[0]],\n                                overflow[alignmentSides[1]]\n                            ];\n                            allOverflows = _to_consumable_array(((_middlewareData$autoP2 = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP2.overflows) || []).concat([\n                                {\n                                    placement: currentPlacement,\n                                    overflows: currentOverflows\n                                }\n                            ]);\n                            nextPlacement = placements$1[currentIndex + 1];\n                            // There are more placements to check.\n                            if (nextPlacement) {\n                                return [\n                                    2,\n                                    {\n                                        data: {\n                                            index: currentIndex + 1,\n                                            overflows: allOverflows\n                                        },\n                                        reset: {\n                                            placement: nextPlacement\n                                        }\n                                    }\n                                ];\n                            }\n                            placementsSortedByMostSpace = allOverflows.map(function(d) {\n                                var alignment = getAlignment(d.placement);\n                                return [\n                                    d.placement,\n                                    alignment && crossAxis ? // Check along the mainAxis and main crossAxis side.\n                                    d.overflows.slice(0, 2).reduce(function(acc, v) {\n                                        return acc + v;\n                                    }, 0) : // Check only the mainAxis.\n                                    d.overflows[0],\n                                    d.overflows\n                                ];\n                            }).sort(function(a, b) {\n                                return a[1] - b[1];\n                            });\n                            placementsThatFitOnEachSide = placementsSortedByMostSpace.filter(function(d) {\n                                return d[2].slice(0, // Aligned placements should not check their opposite crossAxis\n                                // side.\n                                getAlignment(d[0]) ? 2 : 3).every(function(v) {\n                                    return v <= 0;\n                                });\n                            });\n                            resetPlacement = ((_placementsThatFitOnE = placementsThatFitOnEachSide[0]) == null ? void 0 : _placementsThatFitOnE[0]) || placementsSortedByMostSpace[0][0];\n                            if (resetPlacement !== placement) {\n                                return [\n                                    2,\n                                    {\n                                        data: {\n                                            index: currentIndex + 1,\n                                            overflows: allOverflows\n                                        },\n                                        reset: {\n                                            placement: resetPlacement\n                                        }\n                                    }\n                                ];\n                            }\n                            return [\n                                2,\n                                {}\n                            ];\n                    }\n                });\n            })();\n        }\n    };\n};\n/**\n * Optimizes the visibility of the floating element by flipping the `placement`\n * in order to keep it in view when the preferred placement(s) will overflow the\n * clipping boundary. Alternative to `autoPlacement`.\n * @see https://floating-ui.com/docs/flip\n */ var flip = function flip(options) {\n    if (options === void 0) {\n        options = {};\n    }\n    return {\n        name: \"flip\",\n        options: options,\n        fn: function fn(state) {\n            return _async_to_generator(function() {\n                var _middlewareData$arrow, _middlewareData$flip, placement, middlewareData, rects, initialPlacement, platform, elements, _evaluate, tmp, checkMainAxis, tmp1, checkCrossAxis, specifiedFallbackPlacements, _evaluate_fallbackStrategy, fallbackStrategy, _evaluate_fallbackAxisSideDirection, fallbackAxisSideDirection, _evaluate_flipAlignment, flipAlignment, detectOverflowOptions, side, isBasePlacement, rtl, fallbackPlacements, _fallbackPlacements, placements, overflow, overflows, overflowsData, sides, _middlewareData$flip2, _overflowsData$filter, nextIndex, nextPlacement, resetPlacement, _overflowsData$map$so, placement1;\n                return _ts_generator(this, function(_state) {\n                    switch(_state.label){\n                        case 0:\n                            placement = state.placement, middlewareData = state.middlewareData, rects = state.rects, initialPlacement = state.initialPlacement, platform = state.platform, elements = state.elements;\n                            _evaluate = evaluate(options, state), tmp = _evaluate.mainAxis, checkMainAxis = tmp === void 0 ? true : tmp, tmp1 = _evaluate.crossAxis, checkCrossAxis = tmp1 === void 0 ? true : tmp1, specifiedFallbackPlacements = _evaluate.fallbackPlacements, _evaluate_fallbackStrategy = _evaluate.fallbackStrategy, fallbackStrategy = _evaluate_fallbackStrategy === void 0 ? \"bestFit\" : _evaluate_fallbackStrategy, _evaluate_fallbackAxisSideDirection = _evaluate.fallbackAxisSideDirection, fallbackAxisSideDirection = _evaluate_fallbackAxisSideDirection === void 0 ? \"none\" : _evaluate_fallbackAxisSideDirection, _evaluate_flipAlignment = _evaluate.flipAlignment, flipAlignment = _evaluate_flipAlignment === void 0 ? true : _evaluate_flipAlignment, detectOverflowOptions = _object_without_properties(_evaluate, [\n                                \"mainAxis\",\n                                \"crossAxis\",\n                                \"fallbackPlacements\",\n                                \"fallbackStrategy\",\n                                \"fallbackAxisSideDirection\",\n                                \"flipAlignment\"\n                            ]);\n                            // If a reset by the arrow was caused due to an alignment offset being\n                            // added, we should skip any logic now since `flip()` has already done its\n                            // work.\n                            // https://github.com/floating-ui/floating-ui/issues/2549#issuecomment-1719601643\n                            if ((_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {\n                                return [\n                                    2,\n                                    {}\n                                ];\n                            }\n                            side = getSide(placement);\n                            isBasePlacement = getSide(initialPlacement) === initialPlacement;\n                            return [\n                                4,\n                                platform.isRTL == null ? void 0 : platform.isRTL(elements.floating)\n                            ];\n                        case 1:\n                            rtl = _state.sent();\n                            fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [\n                                getOppositePlacement(initialPlacement)\n                            ] : getExpandedPlacements(initialPlacement));\n                            if (!specifiedFallbackPlacements && fallbackAxisSideDirection !== \"none\") {\n                                ;\n                                (_fallbackPlacements = fallbackPlacements).push.apply(_fallbackPlacements, _to_consumable_array(getOppositeAxisPlacements(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl)));\n                            }\n                            placements = [\n                                initialPlacement\n                            ].concat(_to_consumable_array(fallbackPlacements));\n                            return [\n                                4,\n                                detectOverflow(state, detectOverflowOptions)\n                            ];\n                        case 2:\n                            overflow = _state.sent();\n                            overflows = [];\n                            overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];\n                            if (checkMainAxis) {\n                                overflows.push(overflow[side]);\n                            }\n                            if (checkCrossAxis) {\n                                sides = getAlignmentSides(placement, rects, rtl);\n                                overflows.push(overflow[sides[0]], overflow[sides[1]]);\n                            }\n                            overflowsData = _to_consumable_array(overflowsData).concat([\n                                {\n                                    placement: placement,\n                                    overflows: overflows\n                                }\n                            ]);\n                            // One or more sides is overflowing.\n                            if (!overflows.every(function(side) {\n                                return side <= 0;\n                            })) {\n                                ;\n                                nextIndex = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1;\n                                nextPlacement = placements[nextIndex];\n                                if (nextPlacement) {\n                                    // Try next placement and re-run the lifecycle.\n                                    return [\n                                        2,\n                                        {\n                                            data: {\n                                                index: nextIndex,\n                                                overflows: overflowsData\n                                            },\n                                            reset: {\n                                                placement: nextPlacement\n                                            }\n                                        }\n                                    ];\n                                }\n                                // First, find the candidates that fit on the mainAxis side of overflow,\n                                // then find the placement that fits the best on the main crossAxis side.\n                                resetPlacement = (_overflowsData$filter = overflowsData.filter(function(d) {\n                                    return d.overflows[0] <= 0;\n                                }).sort(function(a, b) {\n                                    return a.overflows[1] - b.overflows[1];\n                                })[0]) == null ? void 0 : _overflowsData$filter.placement;\n                                // Otherwise fallback.\n                                if (!resetPlacement) {\n                                    switch(fallbackStrategy){\n                                        case \"bestFit\":\n                                            {\n                                                ;\n                                                placement1 = (_overflowsData$map$so = overflowsData.map(function(d) {\n                                                    return [\n                                                        d.placement,\n                                                        d.overflows.filter(function(overflow) {\n                                                            return overflow > 0;\n                                                        }).reduce(function(acc, overflow) {\n                                                            return acc + overflow;\n                                                        }, 0)\n                                                    ];\n                                                }).sort(function(a, b) {\n                                                    return a[1] - b[1];\n                                                })[0]) == null ? void 0 : _overflowsData$map$so[0];\n                                                if (placement1) {\n                                                    resetPlacement = placement1;\n                                                }\n                                                break;\n                                            }\n                                        case \"initialPlacement\":\n                                            resetPlacement = initialPlacement;\n                                            break;\n                                    }\n                                }\n                                if (placement !== resetPlacement) {\n                                    return [\n                                        2,\n                                        {\n                                            reset: {\n                                                placement: resetPlacement\n                                            }\n                                        }\n                                    ];\n                                }\n                            }\n                            return [\n                                2,\n                                {}\n                            ];\n                    }\n                });\n            })();\n        }\n    };\n};\nfunction getSideOffsets(overflow, rect) {\n    return {\n        top: overflow.top - rect.height,\n        right: overflow.right - rect.width,\n        bottom: overflow.bottom - rect.height,\n        left: overflow.left - rect.width\n    };\n}\nfunction isAnySideFullyClipped(overflow) {\n    return sides.some(function(side) {\n        return overflow[side] >= 0;\n    });\n}\n/**\n * Provides data to hide the floating element in applicable situations, such as\n * when it is not in the same clipping context as the reference element.\n * @see https://floating-ui.com/docs/hide\n */ var hide = function hide(options) {\n    if (options === void 0) {\n        options = {};\n    }\n    return {\n        name: \"hide\",\n        options: options,\n        fn: function fn(state) {\n            return _async_to_generator(function() {\n                var rects, _evaluate, _evaluate_strategy, strategy, detectOverflowOptions, overflow, offsets, overflow1, offsets1;\n                return _ts_generator(this, function(_state) {\n                    switch(_state.label){\n                        case 0:\n                            rects = state.rects;\n                            _evaluate = evaluate(options, state), _evaluate_strategy = _evaluate.strategy, strategy = _evaluate_strategy === void 0 ? \"referenceHidden\" : _evaluate_strategy, detectOverflowOptions = _object_without_properties(_evaluate, [\n                                \"strategy\"\n                            ]);\n                            switch(strategy){\n                                case \"referenceHidden\":\n                                    return [\n                                        3,\n                                        1\n                                    ];\n                                case \"escaped\":\n                                    return [\n                                        3,\n                                        3\n                                    ];\n                            }\n                            return [\n                                3,\n                                5\n                            ];\n                        case 1:\n                            return [\n                                4,\n                                detectOverflow(state, _object_spread_props(_object_spread({}, detectOverflowOptions), {\n                                    elementContext: \"reference\"\n                                }))\n                            ];\n                        case 2:\n                            overflow = _state.sent();\n                            offsets = getSideOffsets(overflow, rects.reference);\n                            return [\n                                2,\n                                {\n                                    data: {\n                                        referenceHiddenOffsets: offsets,\n                                        referenceHidden: isAnySideFullyClipped(offsets)\n                                    }\n                                }\n                            ];\n                        case 3:\n                            return [\n                                4,\n                                detectOverflow(state, _object_spread_props(_object_spread({}, detectOverflowOptions), {\n                                    altBoundary: true\n                                }))\n                            ];\n                        case 4:\n                            overflow1 = _state.sent();\n                            offsets1 = getSideOffsets(overflow1, rects.floating);\n                            return [\n                                2,\n                                {\n                                    data: {\n                                        escapedOffsets: offsets1,\n                                        escaped: isAnySideFullyClipped(offsets1)\n                                    }\n                                }\n                            ];\n                        case 5:\n                            {\n                                return [\n                                    2,\n                                    {}\n                                ];\n                            }\n                            _state.label = 6;\n                        case 6:\n                            return [\n                                2\n                            ];\n                    }\n                });\n            })();\n        }\n    };\n};\nfunction getBoundingRect(rects) {\n    var minX = min.apply(void 0, _to_consumable_array(rects.map(function(rect) {\n        return rect.left;\n    })));\n    var minY = min.apply(void 0, _to_consumable_array(rects.map(function(rect) {\n        return rect.top;\n    })));\n    var maxX = max.apply(void 0, _to_consumable_array(rects.map(function(rect) {\n        return rect.right;\n    })));\n    var maxY = max.apply(void 0, _to_consumable_array(rects.map(function(rect) {\n        return rect.bottom;\n    })));\n    return {\n        x: minX,\n        y: minY,\n        width: maxX - minX,\n        height: maxY - minY\n    };\n}\nfunction getRectsByLine(rects) {\n    var sortedRects = rects.slice().sort(function(a, b) {\n        return a.y - b.y;\n    });\n    var groups = [];\n    var prevRect = null;\n    for(var i = 0; i < sortedRects.length; i++){\n        var rect = sortedRects[i];\n        if (!prevRect || rect.y - prevRect.y > prevRect.height / 2) {\n            groups.push([\n                rect\n            ]);\n        } else {\n            groups[groups.length - 1].push(rect);\n        }\n        prevRect = rect;\n    }\n    return groups.map(function(rect) {\n        return rectToClientRect(getBoundingRect(rect));\n    });\n}\n/**\n * Provides improved positioning for inline reference elements that can span\n * over multiple lines, such as hyperlinks or range selections.\n * @see https://floating-ui.com/docs/inline\n */ var inline = function inline(options) {\n    if (options === void 0) {\n        options = {};\n    }\n    return {\n        name: \"inline\",\n        options: options,\n        fn: function fn(state) {\n            return _async_to_generator(function() {\n                var placement, elements, rects, platform, strategy, _evaluate, _evaluate_padding, padding, x, y, nativeClientRects, _, clientRects, fallback, paddingObject, resetRects;\n                function getBoundingClientRect() {\n                    // There are two rects and they are disjoined.\n                    if (clientRects.length === 2 && clientRects[0].left > clientRects[1].right && x != null && y != null) {\n                        // Find the first rect in which the point is fully inside.\n                        return clientRects.find(function(rect) {\n                            return x > rect.left - paddingObject.left && x < rect.right + paddingObject.right && y > rect.top - paddingObject.top && y < rect.bottom + paddingObject.bottom;\n                        }) || fallback;\n                    }\n                    // There are 2 or more connected rects.\n                    if (clientRects.length >= 2) {\n                        if (getSideAxis(placement) === \"y\") {\n                            var firstRect = clientRects[0];\n                            var lastRect = clientRects[clientRects.length - 1];\n                            var isTop = getSide(placement) === \"top\";\n                            var top = firstRect.top;\n                            var bottom = lastRect.bottom;\n                            var left = isTop ? firstRect.left : lastRect.left;\n                            var right = isTop ? firstRect.right : lastRect.right;\n                            var width = right - left;\n                            var height = bottom - top;\n                            return {\n                                top: top,\n                                bottom: bottom,\n                                left: left,\n                                right: right,\n                                width: width,\n                                height: height,\n                                x: left,\n                                y: top\n                            };\n                        }\n                        var isLeftSide = getSide(placement) === \"left\";\n                        var maxRight = max.apply(void 0, _to_consumable_array(clientRects.map(function(rect) {\n                            return rect.right;\n                        })));\n                        var minLeft = min.apply(void 0, _to_consumable_array(clientRects.map(function(rect) {\n                            return rect.left;\n                        })));\n                        var measureRects = clientRects.filter(function(rect) {\n                            return isLeftSide ? rect.left === minLeft : rect.right === maxRight;\n                        });\n                        var top1 = measureRects[0].top;\n                        var bottom1 = measureRects[measureRects.length - 1].bottom;\n                        var left1 = minLeft;\n                        var right1 = maxRight;\n                        var width1 = right1 - left1;\n                        var height1 = bottom1 - top1;\n                        return {\n                            top: top1,\n                            bottom: bottom1,\n                            left: left1,\n                            right: right1,\n                            width: width1,\n                            height: height1,\n                            x: left1,\n                            y: top1\n                        };\n                    }\n                    return fallback;\n                }\n                return _ts_generator(this, function(_state) {\n                    switch(_state.label){\n                        case 0:\n                            placement = state.placement, elements = state.elements, rects = state.rects, platform = state.platform, strategy = state.strategy;\n                            // A MouseEvent's client{X,Y} coords can be up to 2 pixels off a\n                            // ClientRect's bounds, despite the event listener being triggered. A\n                            // padding of 2 seems to handle this issue.\n                            _evaluate = evaluate(options, state), _evaluate_padding = _evaluate.padding, padding = _evaluate_padding === void 0 ? 2 : _evaluate_padding, x = _evaluate.x, y = _evaluate.y;\n                            _ = Array.from;\n                            return [\n                                4,\n                                platform.getClientRects == null ? void 0 : platform.getClientRects(elements.reference)\n                            ];\n                        case 1:\n                            nativeClientRects = _.apply(Array, [\n                                _state.sent() || []\n                            ]);\n                            clientRects = getRectsByLine(nativeClientRects);\n                            fallback = rectToClientRect(getBoundingRect(nativeClientRects));\n                            paddingObject = getPaddingObject(padding);\n                            return [\n                                4,\n                                platform.getElementRects({\n                                    reference: {\n                                        getBoundingClientRect: getBoundingClientRect\n                                    },\n                                    floating: elements.floating,\n                                    strategy: strategy\n                                })\n                            ];\n                        case 2:\n                            resetRects = _state.sent();\n                            if (rects.reference.x !== resetRects.reference.x || rects.reference.y !== resetRects.reference.y || rects.reference.width !== resetRects.reference.width || rects.reference.height !== resetRects.reference.height) {\n                                return [\n                                    2,\n                                    {\n                                        reset: {\n                                            rects: resetRects\n                                        }\n                                    }\n                                ];\n                            }\n                            return [\n                                2,\n                                {}\n                            ];\n                    }\n                });\n            })();\n        }\n    };\n};\nfunction convertValueToCoords(state, options) {\n    return _convertValueToCoords.apply(this, arguments);\n}\nfunction _convertValueToCoords() {\n    _convertValueToCoords = // For type backwards-compatibility, the `OffsetOptions` type was also\n    // Derivable.\n    _async_to_generator(function(state, options) {\n        var placement, platform, elements, rtl, side, alignment, isVertical, mainAxisMulti, crossAxisMulti, rawValue, _ref, mainAxis, crossAxis, alignmentAxis;\n        return _ts_generator(this, function(_state) {\n            switch(_state.label){\n                case 0:\n                    placement = state.placement, platform = state.platform, elements = state.elements;\n                    return [\n                        4,\n                        platform.isRTL == null ? void 0 : platform.isRTL(elements.floating)\n                    ];\n                case 1:\n                    rtl = _state.sent();\n                    side = getSide(placement);\n                    alignment = getAlignment(placement);\n                    isVertical = getSideAxis(placement) === \"y\";\n                    mainAxisMulti = [\n                        \"left\",\n                        \"top\"\n                    ].includes(side) ? -1 : 1;\n                    crossAxisMulti = rtl && isVertical ? -1 : 1;\n                    rawValue = evaluate(options, state);\n                    // eslint-disable-next-line prefer-const\n                    _ref = typeof rawValue === \"number\" ? {\n                        mainAxis: rawValue,\n                        crossAxis: 0,\n                        alignmentAxis: null\n                    } : _object_spread({\n                        mainAxis: 0,\n                        crossAxis: 0,\n                        alignmentAxis: null\n                    }, rawValue), mainAxis = _ref.mainAxis, crossAxis = _ref.crossAxis, alignmentAxis = _ref.alignmentAxis;\n                    if (alignment && typeof alignmentAxis === \"number\") {\n                        crossAxis = alignment === \"end\" ? alignmentAxis * -1 : alignmentAxis;\n                    }\n                    return [\n                        2,\n                        isVertical ? {\n                            x: crossAxis * crossAxisMulti,\n                            y: mainAxis * mainAxisMulti\n                        } : {\n                            x: mainAxis * mainAxisMulti,\n                            y: crossAxis * crossAxisMulti\n                        }\n                    ];\n            }\n        });\n    });\n    return _convertValueToCoords.apply(this, arguments);\n}\n/**\n * Modifies the placement by translating the floating element along the\n * specified axes.\n * A number (shorthand for `mainAxis` or distance), or an axes configuration\n * object may be passed.\n * @see https://floating-ui.com/docs/offset\n */ var offset = function offset(options) {\n    if (options === void 0) {\n        options = 0;\n    }\n    return {\n        name: \"offset\",\n        options: options,\n        fn: function fn(state) {\n            return _async_to_generator(function() {\n                var x, y, diffCoords;\n                return _ts_generator(this, function(_state) {\n                    switch(_state.label){\n                        case 0:\n                            x = state.x, y = state.y;\n                            return [\n                                4,\n                                convertValueToCoords(state, options)\n                            ];\n                        case 1:\n                            diffCoords = _state.sent();\n                            return [\n                                2,\n                                {\n                                    x: x + diffCoords.x,\n                                    y: y + diffCoords.y,\n                                    data: diffCoords\n                                }\n                            ];\n                    }\n                });\n            })();\n        }\n    };\n};\n/**\n * Optimizes the visibility of the floating element by shifting it in order to\n * keep it in view when it will overflow the clipping boundary.\n * @see https://floating-ui.com/docs/shift\n */ var shift = function shift(options) {\n    if (options === void 0) {\n        options = {};\n    }\n    return {\n        name: \"shift\",\n        options: options,\n        fn: function fn(state) {\n            return _async_to_generator(function() {\n                var x, y, placement, _evaluate, tmp, checkMainAxis, tmp1, checkCrossAxis, _evaluate_limiter, limiter, detectOverflowOptions, coords, overflow, crossAxis, mainAxis, mainAxisCoord, crossAxisCoord, minSide, maxSide, min, max, minSide1, maxSide1, min1, max1, _obj, limitedCoords;\n                return _ts_generator(this, function(_state) {\n                    switch(_state.label){\n                        case 0:\n                            x = state.x, y = state.y, placement = state.placement;\n                            _evaluate = evaluate(options, state), tmp = _evaluate.mainAxis, checkMainAxis = tmp === void 0 ? true : tmp, tmp1 = _evaluate.crossAxis, checkCrossAxis = tmp1 === void 0 ? false : tmp1, _evaluate_limiter = _evaluate.limiter, limiter = _evaluate_limiter === void 0 ? {\n                                fn: function(_ref) {\n                                    var x = _ref.x, y = _ref.y;\n                                    return {\n                                        x: x,\n                                        y: y\n                                    };\n                                }\n                            } : _evaluate_limiter, detectOverflowOptions = _object_without_properties(_evaluate, [\n                                \"mainAxis\",\n                                \"crossAxis\",\n                                \"limiter\"\n                            ]);\n                            coords = {\n                                x: x,\n                                y: y\n                            };\n                            return [\n                                4,\n                                detectOverflow(state, detectOverflowOptions)\n                            ];\n                        case 1:\n                            overflow = _state.sent();\n                            crossAxis = getSideAxis(getSide(placement));\n                            mainAxis = getOppositeAxis(crossAxis);\n                            mainAxisCoord = coords[mainAxis];\n                            crossAxisCoord = coords[crossAxis];\n                            if (checkMainAxis) {\n                                minSide = mainAxis === \"y\" ? \"top\" : \"left\";\n                                maxSide = mainAxis === \"y\" ? \"bottom\" : \"right\";\n                                min = mainAxisCoord + overflow[minSide];\n                                max = mainAxisCoord - overflow[maxSide];\n                                mainAxisCoord = clamp(min, mainAxisCoord, max);\n                            }\n                            if (checkCrossAxis) {\n                                minSide1 = crossAxis === \"y\" ? \"top\" : \"left\";\n                                maxSide1 = crossAxis === \"y\" ? \"bottom\" : \"right\";\n                                min1 = crossAxisCoord + overflow[minSide1];\n                                max1 = crossAxisCoord - overflow[maxSide1];\n                                crossAxisCoord = clamp(min1, crossAxisCoord, max1);\n                            }\n                            limitedCoords = limiter.fn(_object_spread_props(_object_spread({}, state), (_obj = {}, _define_property(_obj, mainAxis, mainAxisCoord), _define_property(_obj, crossAxis, crossAxisCoord), _obj)));\n                            return [\n                                2,\n                                _object_spread_props(_object_spread({}, limitedCoords), {\n                                    data: {\n                                        x: limitedCoords.x - x,\n                                        y: limitedCoords.y - y\n                                    }\n                                })\n                            ];\n                    }\n                });\n            })();\n        }\n    };\n};\n/**\n * Built-in `limiter` that will stop `shift()` at a certain point.\n */ var limitShift = function limitShift(options) {\n    if (options === void 0) {\n        options = {};\n    }\n    return {\n        options: options,\n        fn: function fn(state) {\n            var x = state.x, y = state.y, placement = state.placement, rects = state.rects, middlewareData = state.middlewareData;\n            var _evaluate = evaluate(options, state), _evaluate_offset = _evaluate.offset, offset = _evaluate_offset === void 0 ? 0 : _evaluate_offset, tmp = _evaluate.mainAxis, checkMainAxis = tmp === void 0 ? true : tmp, tmp1 = _evaluate.crossAxis, checkCrossAxis = tmp1 === void 0 ? true : tmp1;\n            var coords = {\n                x: x,\n                y: y\n            };\n            var crossAxis = getSideAxis(placement);\n            var mainAxis = getOppositeAxis(crossAxis);\n            var mainAxisCoord = coords[mainAxis];\n            var crossAxisCoord = coords[crossAxis];\n            var rawOffset = evaluate(offset, state);\n            var computedOffset = typeof rawOffset === \"number\" ? {\n                mainAxis: rawOffset,\n                crossAxis: 0\n            } : _object_spread({\n                mainAxis: 0,\n                crossAxis: 0\n            }, rawOffset);\n            if (checkMainAxis) {\n                var len = mainAxis === \"y\" ? \"height\" : \"width\";\n                var limitMin = rects.reference[mainAxis] - rects.floating[len] + computedOffset.mainAxis;\n                var limitMax = rects.reference[mainAxis] + rects.reference[len] - computedOffset.mainAxis;\n                if (mainAxisCoord < limitMin) {\n                    mainAxisCoord = limitMin;\n                } else if (mainAxisCoord > limitMax) {\n                    mainAxisCoord = limitMax;\n                }\n            }\n            if (checkCrossAxis) {\n                var _middlewareData$offse, _middlewareData$offse2;\n                var len1 = mainAxis === \"y\" ? \"width\" : \"height\";\n                var isOriginSide = [\n                    \"top\",\n                    \"left\"\n                ].includes(getSide(placement));\n                var limitMin1 = rects.reference[crossAxis] - rects.floating[len1] + (isOriginSide ? ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse[crossAxis]) || 0 : 0) + (isOriginSide ? 0 : computedOffset.crossAxis);\n                var limitMax1 = rects.reference[crossAxis] + rects.reference[len1] + (isOriginSide ? 0 : ((_middlewareData$offse2 = middlewareData.offset) == null ? void 0 : _middlewareData$offse2[crossAxis]) || 0) - (isOriginSide ? computedOffset.crossAxis : 0);\n                if (crossAxisCoord < limitMin1) {\n                    crossAxisCoord = limitMin1;\n                } else if (crossAxisCoord > limitMax1) {\n                    crossAxisCoord = limitMax1;\n                }\n            }\n            var _obj;\n            return(_obj = {}, _define_property(_obj, mainAxis, mainAxisCoord), _define_property(_obj, crossAxis, crossAxisCoord), _obj);\n        }\n    };\n};\n/**\n * Provides data that allows you to change the size of the floating element —\n * for instance, prevent it from overflowing the clipping boundary or match the\n * width of the reference element.\n * @see https://floating-ui.com/docs/size\n */ var size = function size(options) {\n    if (options === void 0) {\n        options = {};\n    }\n    return {\n        name: \"size\",\n        options: options,\n        fn: function fn(state) {\n            return _async_to_generator(function() {\n                var placement, rects, platform, elements, _evaluate, _evaluate_apply, apply, detectOverflowOptions, overflow, side, alignment, isYAxis, _rects_floating, width, height, heightSide, widthSide, overflowAvailableHeight, overflowAvailableWidth, noShift, availableHeight, availableWidth, maximumClippingWidth, maximumClippingHeight, xMin, xMax, yMin, yMax, nextDimensions;\n                return _ts_generator(this, function(_state) {\n                    switch(_state.label){\n                        case 0:\n                            placement = state.placement, rects = state.rects, platform = state.platform, elements = state.elements;\n                            _evaluate = evaluate(options, state), _evaluate_apply = _evaluate.apply, apply = _evaluate_apply === void 0 ? function() {} : _evaluate_apply, detectOverflowOptions = _object_without_properties(_evaluate, [\n                                \"apply\"\n                            ]);\n                            return [\n                                4,\n                                detectOverflow(state, detectOverflowOptions)\n                            ];\n                        case 1:\n                            overflow = _state.sent();\n                            side = getSide(placement);\n                            alignment = getAlignment(placement);\n                            isYAxis = getSideAxis(placement) === \"y\";\n                            _rects_floating = rects.floating, width = _rects_floating.width, height = _rects_floating.height;\n                            if (!(side === \"top\" || side === \"bottom\")) return [\n                                3,\n                                3\n                            ];\n                            heightSide = side;\n                            return [\n                                4,\n                                platform.isRTL == null ? void 0 : platform.isRTL(elements.floating)\n                            ];\n                        case 2:\n                            widthSide = alignment === (_state.sent() ? \"start\" : \"end\") ? \"left\" : \"right\";\n                            return [\n                                3,\n                                4\n                            ];\n                        case 3:\n                            widthSide = side;\n                            heightSide = alignment === \"end\" ? \"top\" : \"bottom\";\n                            _state.label = 4;\n                        case 4:\n                            overflowAvailableHeight = height - overflow[heightSide];\n                            overflowAvailableWidth = width - overflow[widthSide];\n                            noShift = !state.middlewareData.shift;\n                            availableHeight = overflowAvailableHeight;\n                            availableWidth = overflowAvailableWidth;\n                            if (isYAxis) {\n                                maximumClippingWidth = width - overflow.left - overflow.right;\n                                availableWidth = alignment || noShift ? min(overflowAvailableWidth, maximumClippingWidth) : maximumClippingWidth;\n                            } else {\n                                maximumClippingHeight = height - overflow.top - overflow.bottom;\n                                availableHeight = alignment || noShift ? min(overflowAvailableHeight, maximumClippingHeight) : maximumClippingHeight;\n                            }\n                            if (noShift && !alignment) {\n                                xMin = max(overflow.left, 0);\n                                xMax = max(overflow.right, 0);\n                                yMin = max(overflow.top, 0);\n                                yMax = max(overflow.bottom, 0);\n                                if (isYAxis) {\n                                    availableWidth = width - 2 * (xMin !== 0 || xMax !== 0 ? xMin + xMax : max(overflow.left, overflow.right));\n                                } else {\n                                    availableHeight = height - 2 * (yMin !== 0 || yMax !== 0 ? yMin + yMax : max(overflow.top, overflow.bottom));\n                                }\n                            }\n                            return [\n                                4,\n                                apply(_object_spread_props(_object_spread({}, state), {\n                                    availableWidth: availableWidth,\n                                    availableHeight: availableHeight\n                                }))\n                            ];\n                        case 5:\n                            _state.sent();\n                            return [\n                                4,\n                                platform.getDimensions(elements.floating)\n                            ];\n                        case 6:\n                            nextDimensions = _state.sent();\n                            if (width !== nextDimensions.width || height !== nextDimensions.height) {\n                                return [\n                                    2,\n                                    {\n                                        reset: {\n                                            rects: true\n                                        }\n                                    }\n                                ];\n                            }\n                            return [\n                                2,\n                                {}\n                            ];\n                    }\n                });\n            })();\n        }\n    };\n};\nexport { arrow, autoPlacement, computePosition, detectOverflow, flip, hide, inline, limitShift, offset, shift, size };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}