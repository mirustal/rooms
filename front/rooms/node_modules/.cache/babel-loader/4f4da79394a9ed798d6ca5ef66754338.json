{"ast":null,"code":"import { _ as _object_spread } from \"@swc/helpers/_/_object_spread\";\nimport { _ as _object_spread_props } from \"@swc/helpers/_/_object_spread_props\";\nimport { _ as _sliced_to_array } from \"@swc/helpers/_/_sliced_to_array\";\nimport * as React from \"react\";\nimport { rescale } from \"../../helpers/math\";\nexport var toPercent = function (v, min, max) {\n  return (v - min) / (max - min) * 100;\n};\nexport var offsetToValue = function (startX, width, min, max, step) {\n  return rescale(startX, [0, width], [min, max], {\n    step: step\n  });\n};\nvar restrictValueByMinMax = function (value, min, max) {\n  if (value < min) {\n    return min;\n  }\n  if (value > max) {\n    return max;\n  }\n  return value;\n};\nexport var updateInternalStateValue = function (prevValue, nextValue, min, max, dragging) {\n  var _prevValue = _sliced_to_array(prevValue, 2),\n    prevStartValue = _prevValue[0],\n    prevEndValue = _prevValue[1];\n  if (prevEndValue === null) {\n    return [restrictValueByMinMax(nextValue, min, max), null];\n  }\n  switch (dragging) {\n    case \"start\":\n      return nextValue > prevEndValue ? [prevEndValue, prevEndValue] : [restrictValueByMinMax(nextValue, min, max), prevEndValue];\n    case \"end\":\n      return nextValue < prevStartValue ? [prevStartValue, prevStartValue] : [prevStartValue, restrictValueByMinMax(nextValue, min, max)];\n    case null:\n    default:\n      return prevValue;\n  }\n};\nexport var updateInternalStateValueByNativeChange = function (prevValue, nextValue, dragging) {\n  var _prevValue = _sliced_to_array(prevValue, 2),\n    prevStartValue = _prevValue[0],\n    prevEndValue = _prevValue[1];\n  switch (dragging) {\n    case \"start\":\n      return [nextValue, prevEndValue];\n    case \"end\":\n      return [prevStartValue, nextValue];\n    case null:\n    default:\n      return prevValue;\n  }\n};\nexport function isMultipleValues(value) {\n  return value[1] !== null;\n}\nexport var snapDirection = function (prevValue, nextValue, type) {\n  if (type === \"start\") {\n    return \"start\";\n  }\n  if (type === \"end\") {\n    return \"end\";\n  }\n  var _prevValue = _sliced_to_array(prevValue, 2),\n    startRaw = _prevValue[0],\n    endRaw = _prevValue[1];\n  /* startRaw и endRaw могут быть равны, поэтому насильно добавляем разницу. */\n  var FORCE_DIFF_VALUE = 0.1;\n  var start = endRaw !== null ? startRaw - FORCE_DIFF_VALUE : startRaw;\n  var end = endRaw !== null ? endRaw + FORCE_DIFF_VALUE : 0;\n  return Math.abs(start - nextValue) <= Math.abs(end - nextValue) ? \"start\" : \"end\";\n};\nexport var getDraggingTypeByTargetDataset = function (target) {\n  if (target) {\n    if (target.dataset.type === \"start\") {\n      return \"start\";\n    }\n    if (target.dataset.type === \"end\") {\n      return \"end\";\n    }\n  }\n  return null;\n};\nvar resetProps = {\n  \"aria-label\": undefined,\n  \"aria-valuetext\": undefined,\n  \"aria-labelledby\": undefined\n};\nexport var extractSliderAriaAttributesFromRestProps = function (restProps) {\n  var ariaLabel = restProps[\"aria-label\"];\n  var ariaValueText = restProps[\"aria-valuetext\"];\n  var ariaLabelledBy = restProps[\"aria-labelledby\"];\n  return _object_spread_props(_object_spread({}, restProps, resetProps), {\n    ariaLabel: ariaLabel,\n    ariaValueText: ariaValueText,\n    ariaLabelledBy: ariaLabelledBy\n  });\n};","map":{"version":3,"names":["React","rescale","toPercent","v","min","max","offsetToValue","startX","width","step","restrictValueByMinMax","value","updateInternalStateValue","prevValue","nextValue","dragging","_prevValue","_sliced_to_array","prevStartValue","prevEndValue","updateInternalStateValueByNativeChange","isMultipleValues","snapDirection","type","startRaw","endRaw","FORCE_DIFF_VALUE","start","end","Math","abs","getDraggingTypeByTargetDataset","target","dataset","resetProps","undefined","extractSliderAriaAttributesFromRestProps","restProps","ariaLabel","ariaValueText","ariaLabelledBy","_object_spread_props","_object_spread"],"sources":["../../../src/components/Slider/helpers.ts"],"sourcesContent":["import * as React from 'react';\nimport { rescale } from '../../helpers/math';\nimport type { InternalDraggingType, InternalValueState } from './types';\n\nexport const toPercent = (v: number, min: number, max: number) => ((v - min) / (max - min)) * 100;\n\nexport const offsetToValue = (\n  startX: number,\n  width: number,\n  min: number,\n  max: number,\n  step?: number,\n) => {\n  return rescale(startX, [0, width], [min, max], { step });\n};\n\nconst restrictValueByMinMax = (value: number, min: number, max: number) => {\n  if (value < min) {\n    return min;\n  }\n  if (value > max) {\n    return max;\n  }\n  return value;\n};\n\nexport const updateInternalStateValue = (\n  prevValue: InternalValueState,\n  nextValue: number,\n  min: number,\n  max: number,\n  dragging: InternalDraggingType | null,\n): InternalValueState => {\n  const [prevStartValue, prevEndValue] = prevValue;\n\n  if (prevEndValue === null) {\n    return [restrictValueByMinMax(nextValue, min, max), null];\n  }\n\n  switch (dragging) {\n    case 'start':\n      return nextValue > prevEndValue\n        ? [prevEndValue, prevEndValue]\n        : [restrictValueByMinMax(nextValue, min, max), prevEndValue];\n    case 'end':\n      return nextValue < prevStartValue\n        ? [prevStartValue, prevStartValue]\n        : [prevStartValue, restrictValueByMinMax(nextValue, min, max)];\n    case null:\n    default:\n      return prevValue;\n  }\n};\n\nexport const updateInternalStateValueByNativeChange = (\n  prevValue: InternalValueState,\n  nextValue: number,\n  dragging: InternalDraggingType | null,\n): InternalValueState => {\n  const [prevStartValue, prevEndValue] = prevValue;\n  switch (dragging) {\n    case 'start':\n      return [nextValue, prevEndValue];\n    case 'end':\n      return [prevStartValue, nextValue];\n    case null:\n    default:\n      return prevValue;\n  }\n};\n\nexport function isMultipleValues(value: InternalValueState): value is [number, number] {\n  return value[1] !== null;\n}\n\nexport const snapDirection = (\n  prevValue: InternalValueState,\n  nextValue: number,\n  type: InternalDraggingType | null,\n) => {\n  if (type === 'start') {\n    return 'start';\n  }\n  if (type === 'end') {\n    return 'end';\n  }\n\n  const [startRaw, endRaw] = prevValue;\n  /* startRaw и endRaw могут быть равны, поэтому насильно добавляем разницу. */\n  const FORCE_DIFF_VALUE = 0.1;\n  const start = endRaw !== null ? startRaw - FORCE_DIFF_VALUE : startRaw;\n  const end = endRaw !== null ? endRaw + FORCE_DIFF_VALUE : 0;\n  return Math.abs(start - nextValue) <= Math.abs(end - nextValue) ? 'start' : 'end';\n};\n\nexport const getDraggingTypeByTargetDataset = <T extends (EventTarget & HTMLElement) | null>(\n  target: T,\n) => {\n  if (target) {\n    if (target.dataset.type === 'start') {\n      return 'start';\n    }\n    if (target.dataset.type === 'end') {\n      return 'end';\n    }\n  }\n  return null;\n};\n\nconst resetProps = {\n  'aria-label': undefined,\n  'aria-valuetext': undefined,\n  'aria-labelledby': undefined,\n};\n\nexport const extractSliderAriaAttributesFromRestProps = <T extends React.AriaAttributes>(\n  restProps: T,\n) => {\n  const ariaLabel = restProps['aria-label'];\n  const ariaValueText = restProps['aria-valuetext'];\n  const ariaLabelledBy = restProps['aria-labelledby'];\n  return { ...restProps, ...resetProps, ariaLabel, ariaValueText, ariaLabelledBy };\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}