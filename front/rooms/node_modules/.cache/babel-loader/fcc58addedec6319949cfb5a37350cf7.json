{"ast":null,"code":"import { _ as _object_spread } from \"@swc/helpers/_/_object_spread\";\nimport { _ as _object_spread_props } from \"@swc/helpers/_/_object_spread_props\";\nimport { _ as _object_without_properties } from \"@swc/helpers/_/_object_without_properties\";\nimport { _ as _sliced_to_array } from \"@swc/helpers/_/_sliced_to_array\";\nimport * as React from \"react\";\nimport { classNames } from \"@vkontakte/vkjs\";\nimport { clamp } from \"../../helpers/math\";\nimport { useGlobalEventListener } from \"../../hooks/useGlobalEventListener\";\nimport { usePlatform } from \"../../hooks/usePlatform\";\nimport { usePrevious } from \"../../hooks/usePrevious\";\nimport { useTimeout } from \"../../hooks/useTimeout\";\nimport { useDOM } from \"../../lib/dom\";\nimport { Platform } from \"../../lib/platform\";\nimport { runTapticImpactOccurred } from \"../../lib/taptic\";\nimport { coordY } from \"../../lib/touch\";\nimport { useIsomorphicLayoutEffect } from \"../../lib/useIsomorphicLayoutEffect\";\nimport { useScroll } from \"../AppRoot/ScrollContext\";\nimport { FixedLayout } from \"../FixedLayout/FixedLayout\";\nimport { Touch } from \"../Touch/Touch\";\nimport TouchRootContext from \"../Touch/TouchContext\";\nimport { PullToRefreshSpinner } from \"./PullToRefreshSpinner\";\nfunction cancelEvent(event) {\n  if (!event) {\n    return false;\n  }\n  while (event.originalEvent) {\n    event = event.originalEvent;\n  }\n  if (event.preventDefault && event.cancelable) {\n    event.preventDefault();\n  }\n  if (event.stopPropagation) {\n    event.stopPropagation();\n  }\n  return false;\n}\nvar TOUCH_MOVE_EVENT_PARAMS = {\n  cancelable: true,\n  passive: false\n};\n/**\n * @see https://vkcom.github.io/VKUI/#/PullToRefresh\n */\nexport var PullToRefresh = function (_param) {\n  var children = _param.children,\n    isFetching = _param.isFetching,\n    onRefresh = _param.onRefresh,\n    className = _param.className,\n    restProps = _object_without_properties(_param, [\"children\", \"isFetching\", \"onRefresh\", \"className\"]);\n  var platform = usePlatform();\n  var scroll = useScroll();\n  var document = useDOM().document;\n  var prevIsFetching = usePrevious(isFetching);\n  var initParams = React.useMemo(function () {\n    return {\n      start: platform === Platform.IOS ? -10 : -45,\n      max: platform === Platform.IOS ? 50 : 80,\n      maxY: platform === Platform.IOS ? 400 : 80,\n      refreshing: platform === Platform.IOS ? 36 : 50,\n      positionMultiplier: platform === Platform.IOS ? 0.21 : 1\n    };\n  }, [platform]);\n  var _React_useState = _sliced_to_array(React.useState(initParams.start), 2),\n    spinnerY = _React_useState[0],\n    setSpinnerY = _React_useState[1];\n  var _React_useState1 = _sliced_to_array(React.useState(false), 2),\n    watching = _React_useState1[0],\n    setWatching = _React_useState1[1];\n  var _React_useState2 = _sliced_to_array(React.useState(false), 2),\n    refreshing = _React_useState2[0],\n    setRefreshing = _React_useState2[1];\n  var _React_useState3 = _sliced_to_array(React.useState(false), 2),\n    canRefresh = _React_useState3[0],\n    setCanRefresh = _React_useState3[1];\n  var _React_useState4 = _sliced_to_array(React.useState(false), 2),\n    touchDown = _React_useState4[0],\n    setTouchDown = _React_useState4[1];\n  var prevTouchDown = usePrevious(touchDown);\n  var touchY = React.useRef(0);\n  var _React_useState5 = _sliced_to_array(React.useState(0), 2),\n    contentShift = _React_useState5[0],\n    setContentShift = _React_useState5[1];\n  var _React_useState6 = _sliced_to_array(React.useState(0), 2),\n    spinnerProgress = _React_useState6[0],\n    setSpinnerProgress = _React_useState6[1];\n  var resetRefreshingState = React.useCallback(function () {\n    setWatching(false);\n    setCanRefresh(false);\n    setRefreshing(false);\n    setSpinnerY(initParams.start);\n    setSpinnerProgress(0);\n    setContentShift(0);\n  }, [initParams]);\n  var onRefreshingFinish = React.useCallback(function () {\n    if (!touchDown) {\n      resetRefreshingState();\n    }\n  }, [touchDown, resetRefreshingState]);\n  var _useTimeout = useTimeout(onRefreshingFinish, 1000),\n    setWaitFetchingTimeout = _useTimeout.set,\n    clearWaitFetchingTimeout = _useTimeout.clear;\n  useIsomorphicLayoutEffect(function () {\n    if (prevIsFetching !== undefined && prevIsFetching && !isFetching) {\n      onRefreshingFinish();\n    }\n  }, [prevIsFetching, isFetching, onRefreshingFinish]);\n  useIsomorphicLayoutEffect(function () {\n    if (prevIsFetching !== undefined && !prevIsFetching && isFetching) {\n      clearWaitFetchingTimeout();\n    }\n  }, [isFetching, prevIsFetching, clearWaitFetchingTimeout]);\n  var runRefreshing = React.useCallback(function () {\n    if (!refreshing && onRefresh) {\n      // cleanup if the consumer does not start fetching in 1s\n      setWaitFetchingTimeout();\n      setRefreshing(true);\n      setSpinnerY(function (prevSpinnerY) {\n        return platform === Platform.IOS ? prevSpinnerY : initParams.refreshing;\n      });\n      var runTapticImpactOccurredCalled = onRefresh();\n      // TODO [>=6]: удалить блок кода (#5049)\n      if (!runTapticImpactOccurredCalled) {\n        runTapticImpactOccurred(\"light\");\n      }\n    }\n  }, [refreshing, onRefresh, setWaitFetchingTimeout, platform, initParams.refreshing]);\n  useIsomorphicLayoutEffect(function () {\n    if (prevTouchDown !== undefined && prevTouchDown && !touchDown) {\n      if (!refreshing && canRefresh) {\n        runRefreshing();\n      } else if (refreshing && !isFetching) {\n        // only iOS can start refresh before gesture end\n        resetRefreshingState();\n      } else {\n        // refreshing && isFetching: refresh in progress\n        // OR !refreshing && !canRefresh: pull was not strong enough\n        setSpinnerY(refreshing ? initParams.refreshing : initParams.start);\n        setSpinnerProgress(0);\n        setContentShift(0);\n      }\n    }\n  }, [initParams, prevIsFetching, isFetching, onRefreshingFinish, prevTouchDown, touchDown, refreshing, canRefresh, runRefreshing]);\n  var startYRef = React.useRef(0);\n  var onTouchStart = function (e) {\n    if (refreshing) {\n      cancelEvent(e);\n    }\n    setTouchDown(true);\n    startYRef.current = e.startY;\n    if (document) {\n      // eslint-disable-next-line no-restricted-properties\n      document.documentElement.classList.add(\"vkui--disable-overscroll-behavior\");\n    }\n  };\n  var shouldPreventTouchMove = function (event) {\n    if (watching || refreshing) {\n      return true;\n    }\n    /* Нам нужно запретить touchmove у документа как только стало понятно, что\n    * начинается pull.\n    * состояния watching и refreshing устанавливаются слишком поздно и браузер\n    * может успеть начать нативный pull to refresh.\n    *\n    * Этот код является запасным вариантом, на случай, если css свойство\n    * overscroll-behavior не поддерживается\n    * */\n    var shiftY = coordY(event) - startYRef.current;\n    var pageYOffset = scroll === null || scroll === void 0 ? void 0 : scroll.getScroll().y;\n    var isRefreshGestureStarted = pageYOffset === 0 && shiftY > 0 && touchDown;\n    return isRefreshGestureStarted;\n  };\n  var onWindowTouchMove = function (event) {\n    if (shouldPreventTouchMove(event)) {\n      event.preventDefault();\n      event.stopPropagation();\n    }\n  };\n  useGlobalEventListener(document, \"touchmove\", onWindowTouchMove, TOUCH_MOVE_EVENT_PARAMS);\n  var onTouchMove = function (e) {\n    var isY = e.isY,\n      shiftY = e.shiftY;\n    var start = initParams.start,\n      max = initParams.max;\n    var pageYOffset = scroll === null || scroll === void 0 ? void 0 : scroll.getScroll().y;\n    if (watching && touchDown) {\n      cancelEvent(e);\n      var positionMultiplier = initParams.positionMultiplier,\n        maxY = initParams.maxY;\n      var shift = Math.max(0, shiftY - touchY.current);\n      var currentY = clamp(start + shift * positionMultiplier, start, maxY);\n      var progress = currentY > -10 ? Math.abs((currentY + 10) / max) * 80 : 0;\n      setSpinnerY(currentY);\n      setSpinnerProgress(clamp(progress, 0, 80));\n      setCanRefresh(progress > 80);\n      setContentShift((currentY + 10) * 2.3);\n      if (progress > 85 && !refreshing && platform === Platform.IOS) {\n        runRefreshing();\n      }\n    } else if (isY && pageYOffset === 0 && shiftY > 0 && !refreshing && touchDown) {\n      cancelEvent(e);\n      touchY.current = shiftY;\n      setWatching(true);\n      setSpinnerY(start);\n      setSpinnerProgress(0);\n    }\n  };\n  var onTouchEnd = function () {\n    setWatching(false);\n    setTouchDown(false);\n    // восстанавливаем overscroll behavior\n    if (document) {\n      // eslint-disable-next-line no-restricted-properties\n      document.documentElement.classList.remove(\"vkui--disable-overscroll-behavior\");\n    }\n  };\n  var spinnerTransform = \"translate3d(0, \".concat(spinnerY, \"px, 0)\");\n  var contentTransform = \"\";\n  if (platform === Platform.IOS && refreshing && !touchDown) {\n    contentTransform = \"translate3d(0, 100px, 0)\";\n  } else if (platform === Platform.IOS && (contentShift || refreshing)) {\n    contentTransform = \"translate3d(0, \".concat(contentShift, \"px, 0)\");\n  }\n  return /*#__PURE__*/React.createElement(TouchRootContext.Provider, {\n    value: true\n  }, /*#__PURE__*/React.createElement(Touch, _object_spread_props(_object_spread({}, restProps), {\n    onStart: onTouchStart,\n    onMove: onTouchMove,\n    onEnd: onTouchEnd,\n    className: classNames(\"vkuiPullToRefresh\", platform === Platform.IOS && \"vkuiPullToRefresh--ios\", watching && \"vkuiPullToRefresh--watching\", refreshing && \"vkuiPullToRefresh--refreshing\", className)\n  }), /*#__PURE__*/React.createElement(FixedLayout, {\n    className: \"vkuiPullToRefresh__controls\",\n    useParentWidth: true\n  }, /*#__PURE__*/React.createElement(PullToRefreshSpinner, {\n    style: {\n      transform: spinnerTransform,\n      WebkitTransform: spinnerTransform,\n      opacity: watching || refreshing || canRefresh ? 1 : 0\n    },\n    on: refreshing,\n    progress: refreshing ? undefined : spinnerProgress\n  })), /*#__PURE__*/React.createElement(\"div\", {\n    className: \"vkuiPullToRefresh__content\",\n    style: {\n      transform: contentTransform,\n      WebkitTransform: contentTransform\n    }\n  }, children)));\n};","map":{"version":3,"names":["React","classNames","clamp","useGlobalEventListener","usePlatform","usePrevious","useTimeout","useDOM","Platform","runTapticImpactOccurred","coordY","useIsomorphicLayoutEffect","useScroll","FixedLayout","Touch","TouchRootContext","PullToRefreshSpinner","cancelEvent","event","originalEvent","preventDefault","cancelable","stopPropagation","TOUCH_MOVE_EVENT_PARAMS","passive","PullToRefresh","_param","children","isFetching","onRefresh","className","restProps","_object_without_properties","platform","scroll","document","prevIsFetching","initParams","useMemo","start","IOS","max","maxY","refreshing","positionMultiplier","_React_useState","_sliced_to_array","useState","spinnerY","setSpinnerY","_React_useState1","watching","setWatching","_React_useState2","setRefreshing","_React_useState3","canRefresh","setCanRefresh","_React_useState4","touchDown","setTouchDown","prevTouchDown","touchY","useRef","_React_useState5","contentShift","setContentShift","_React_useState6","spinnerProgress","setSpinnerProgress","resetRefreshingState","useCallback","onRefreshingFinish","_useTimeout","setWaitFetchingTimeout","set","clearWaitFetchingTimeout","clear","undefined","runRefreshing","prevSpinnerY","runTapticImpactOccurredCalled","startYRef","onTouchStart","e","current","startY","documentElement","classList","add","shouldPreventTouchMove","shiftY","pageYOffset","getScroll","y","isRefreshGestureStarted","onWindowTouchMove","onTouchMove","isY","shift","Math","currentY","progress","abs","onTouchEnd","remove","spinnerTransform","concat","contentTransform","createElement","Provider","value","_object_spread_props","_object_spread","onStart","onMove","onEnd","useParentWidth","style","transform","WebkitTransform","opacity","on"],"sources":["../../../src/components/PullToRefresh/PullToRefresh.tsx"],"sourcesContent":["import * as React from 'react';\nimport { classNames } from '@vkontakte/vkjs';\nimport { clamp } from '../../helpers/math';\nimport { useGlobalEventListener } from '../../hooks/useGlobalEventListener';\nimport { usePlatform } from '../../hooks/usePlatform';\nimport { usePrevious } from '../../hooks/usePrevious';\nimport { useTimeout } from '../../hooks/useTimeout';\nimport { DOMProps, useDOM } from '../../lib/dom';\nimport { Platform } from '../../lib/platform';\nimport { runTapticImpactOccurred } from '../../lib/taptic';\nimport { coordY, VKUITouchEvent } from '../../lib/touch';\nimport { useIsomorphicLayoutEffect } from '../../lib/useIsomorphicLayoutEffect';\nimport { AnyFunction, HasChildren } from '../../types';\nimport { ScrollContextInterface, useScroll } from '../AppRoot/ScrollContext';\nimport { FixedLayout } from '../FixedLayout/FixedLayout';\nimport { Touch, TouchEvent, TouchProps } from '../Touch/Touch';\nimport TouchRootContext from '../Touch/TouchContext';\nimport { PullToRefreshSpinner } from './PullToRefreshSpinner';\nimport styles from './PullToRefresh.module.css';\n\nfunction cancelEvent(event: any) {\n  if (!event) {\n    return false;\n  }\n  while (event.originalEvent) {\n    event = event.originalEvent;\n  }\n  if (event.preventDefault && event.cancelable) {\n    event.preventDefault();\n  }\n  if (event.stopPropagation) {\n    event.stopPropagation();\n  }\n  return false;\n}\n\nexport interface PullToRefreshProps extends DOMProps, TouchProps, HasChildren {\n  /**\n   * Будет вызвана для обновления контента (прим.: функция должна быть мемоизированным коллбэком)\n   *\n   * > ⚠️ **Для разработчиков VK Mini Apps**\n   * >\n   * > Сейчас метод под конец выполнения вызывает `runTapticImpactOccurred()`.\n   * >\n   * > В **v6** нужно будет самостоятельно вызывать эту функцию в вашем обработчике `onRefresh()`.\n   * > (см. https://github.com/VKCOM/VKUI/issues/5049). Функцию можете импортировать её из\n   * > бибилиотеки `@vkontakte/vk-bridge-react`.\n   * >\n   * > Чтобы подготовить ваше мини-приложение к обновлению до **v6**, в рамках **v5** вы уже можете\n   * > вызывать `runTapticImpactOccurred()`, но с одним условием: вы должны вернуть результат\n   * > выполнения функции, чтобы исключить двойной вызов. Результат функции — `boolean`. Если\n   * > вернётся `true`, значит, вызывать `runTapticImpactOccurred()` снова со стороны **VKUI** —\n   * > не нужно.\n   * >\n   * > ```jsx\n   * > const onRefresh = React.useCallback(() => {\n   * >  // ...\n   * >  return runTapticImpactOccurred();\n   * > }, []);\n   * >\n   * > // <PullToRefresh onRefresh={onRefresh} />\n   * > ```\n   * >\n   * > Соответственно, в **v6** ничего возвращать уже не потребуется.\n   */\n  onRefresh: AnyFunction;\n  /**\n   * Определяет, выполняется ли обновление. Для скрытия спиннера после получения контента необходимо передать `false`\n   */\n  isFetching?: boolean;\n  /** @ignore */\n  scroll?: ScrollContextInterface;\n}\n\nconst TOUCH_MOVE_EVENT_PARAMS = {\n  cancelable: true,\n  passive: false,\n};\n\n/**\n * @see https://vkcom.github.io/VKUI/#/PullToRefresh\n */\nexport const PullToRefresh = ({\n  children,\n  isFetching,\n  onRefresh,\n  className,\n  ...restProps\n}: PullToRefreshProps) => {\n  const platform = usePlatform();\n  const scroll = useScroll();\n  const { document } = useDOM();\n  const prevIsFetching = usePrevious(isFetching);\n\n  const initParams = React.useMemo(\n    () => ({\n      start: platform === Platform.IOS ? -10 : -45,\n      max: platform === Platform.IOS ? 50 : 80,\n      maxY: platform === Platform.IOS ? 400 : 80,\n      refreshing: platform === Platform.IOS ? 36 : 50,\n      positionMultiplier: platform === Platform.IOS ? 0.21 : 1,\n    }),\n    [platform],\n  );\n\n  const [spinnerY, setSpinnerY] = React.useState(initParams.start);\n  const [watching, setWatching] = React.useState(false);\n  const [refreshing, setRefreshing] = React.useState(false);\n  const [canRefresh, setCanRefresh] = React.useState(false);\n  const [touchDown, setTouchDown] = React.useState(false);\n  const prevTouchDown = usePrevious(touchDown);\n\n  const touchY = React.useRef(0);\n  const [contentShift, setContentShift] = React.useState(0);\n  const [spinnerProgress, setSpinnerProgress] = React.useState(0);\n\n  const resetRefreshingState = React.useCallback(() => {\n    setWatching(false);\n    setCanRefresh(false);\n    setRefreshing(false);\n    setSpinnerY(initParams.start);\n    setSpinnerProgress(0);\n    setContentShift(0);\n  }, [initParams]);\n\n  const onRefreshingFinish = React.useCallback(() => {\n    if (!touchDown) {\n      resetRefreshingState();\n    }\n  }, [touchDown, resetRefreshingState]);\n\n  const { set: setWaitFetchingTimeout, clear: clearWaitFetchingTimeout } = useTimeout(\n    onRefreshingFinish,\n    1000,\n  );\n\n  useIsomorphicLayoutEffect(() => {\n    if (prevIsFetching !== undefined && prevIsFetching && !isFetching) {\n      onRefreshingFinish();\n    }\n  }, [prevIsFetching, isFetching, onRefreshingFinish]);\n\n  useIsomorphicLayoutEffect(() => {\n    if (prevIsFetching !== undefined && !prevIsFetching && isFetching) {\n      clearWaitFetchingTimeout();\n    }\n  }, [isFetching, prevIsFetching, clearWaitFetchingTimeout]);\n\n  const runRefreshing = React.useCallback(() => {\n    if (!refreshing && onRefresh) {\n      // cleanup if the consumer does not start fetching in 1s\n      setWaitFetchingTimeout();\n\n      setRefreshing(true);\n      setSpinnerY((prevSpinnerY) =>\n        platform === Platform.IOS ? prevSpinnerY : initParams.refreshing,\n      );\n\n      const runTapticImpactOccurredCalled = onRefresh();\n      // TODO [>=6]: удалить блок кода (#5049)\n      if (!runTapticImpactOccurredCalled) {\n        runTapticImpactOccurred('light');\n      }\n    }\n  }, [refreshing, onRefresh, setWaitFetchingTimeout, platform, initParams.refreshing]);\n\n  useIsomorphicLayoutEffect(() => {\n    if (prevTouchDown !== undefined && prevTouchDown && !touchDown) {\n      if (!refreshing && canRefresh) {\n        runRefreshing();\n      } else if (refreshing && !isFetching) {\n        // only iOS can start refresh before gesture end\n        resetRefreshingState();\n      } else {\n        // refreshing && isFetching: refresh in progress\n        // OR !refreshing && !canRefresh: pull was not strong enough\n        setSpinnerY(refreshing ? initParams.refreshing : initParams.start);\n        setSpinnerProgress(0);\n        setContentShift(0);\n      }\n    }\n  }, [\n    initParams,\n    prevIsFetching,\n    isFetching,\n    onRefreshingFinish,\n    prevTouchDown,\n    touchDown,\n    refreshing,\n    canRefresh,\n    runRefreshing,\n  ]);\n\n  const startYRef = React.useRef(0);\n\n  const onTouchStart = (e: TouchEvent) => {\n    if (refreshing) {\n      cancelEvent(e);\n    }\n    setTouchDown(true);\n    startYRef.current = e.startY;\n\n    if (document) {\n      // eslint-disable-next-line no-restricted-properties\n      document.documentElement.classList.add('vkui--disable-overscroll-behavior');\n    }\n  };\n\n  const shouldPreventTouchMove = (event: VKUITouchEvent) => {\n    if (watching || refreshing) {\n      return true;\n    }\n\n    /* Нам нужно запретить touchmove у документа как только стало понятно, что\n     * начинается pull.\n     * состояния watching и refreshing устанавливаются слишком поздно и браузер\n     * может успеть начать нативный pull to refresh.\n     *\n     * Этот код является запасным вариантом, на случай, если css свойство\n     * overscroll-behavior не поддерживается\n     * */\n    const shiftY = coordY(event) - startYRef.current;\n    const pageYOffset = scroll?.getScroll().y;\n    const isRefreshGestureStarted = pageYOffset === 0 && shiftY > 0 && touchDown;\n    return isRefreshGestureStarted;\n  };\n\n  const onWindowTouchMove = (event: VKUITouchEvent) => {\n    if (shouldPreventTouchMove(event)) {\n      event.preventDefault();\n      event.stopPropagation();\n    }\n  };\n\n  useGlobalEventListener(document, 'touchmove', onWindowTouchMove, TOUCH_MOVE_EVENT_PARAMS);\n\n  const onTouchMove = (e: TouchEvent) => {\n    const { isY, shiftY } = e;\n    const { start, max } = initParams;\n    const pageYOffset = scroll?.getScroll().y;\n\n    if (watching && touchDown) {\n      cancelEvent(e);\n\n      const { positionMultiplier, maxY } = initParams;\n\n      const shift = Math.max(0, shiftY - touchY.current);\n\n      const currentY = clamp(start + shift * positionMultiplier, start, maxY);\n      const progress = currentY > -10 ? Math.abs((currentY + 10) / max) * 80 : 0;\n\n      setSpinnerY(currentY);\n      setSpinnerProgress(clamp(progress, 0, 80));\n      setCanRefresh(progress > 80);\n      setContentShift((currentY + 10) * 2.3);\n\n      if (progress > 85 && !refreshing && platform === Platform.IOS) {\n        runRefreshing();\n      }\n    } else if (isY && pageYOffset === 0 && shiftY > 0 && !refreshing && touchDown) {\n      cancelEvent(e);\n\n      touchY.current = shiftY;\n      setWatching(true);\n      setSpinnerY(start);\n      setSpinnerProgress(0);\n    }\n  };\n\n  const onTouchEnd = () => {\n    setWatching(false);\n    setTouchDown(false);\n\n    // восстанавливаем overscroll behavior\n    if (document) {\n      // eslint-disable-next-line no-restricted-properties\n      document.documentElement.classList.remove('vkui--disable-overscroll-behavior');\n    }\n  };\n\n  const spinnerTransform = `translate3d(0, ${spinnerY}px, 0)`;\n  let contentTransform = '';\n\n  if (platform === Platform.IOS && refreshing && !touchDown) {\n    contentTransform = 'translate3d(0, 100px, 0)';\n  } else if (platform === Platform.IOS && (contentShift || refreshing)) {\n    contentTransform = `translate3d(0, ${contentShift}px, 0)`;\n  }\n\n  return (\n    <TouchRootContext.Provider value={true}>\n      <Touch\n        {...restProps}\n        onStart={onTouchStart}\n        onMove={onTouchMove}\n        onEnd={onTouchEnd}\n        className={classNames(\n          styles['PullToRefresh'],\n          platform === Platform.IOS && styles['PullToRefresh--ios'],\n          watching && styles['PullToRefresh--watching'],\n          refreshing && styles['PullToRefresh--refreshing'],\n          className,\n        )}\n      >\n        <FixedLayout className={styles['PullToRefresh__controls']} useParentWidth>\n          <PullToRefreshSpinner\n            style={{\n              transform: spinnerTransform,\n              WebkitTransform: spinnerTransform,\n              opacity: watching || refreshing || canRefresh ? 1 : 0,\n            }}\n            on={refreshing}\n            progress={refreshing ? undefined : spinnerProgress}\n          />\n        </FixedLayout>\n\n        <div\n          className={styles['PullToRefresh__content']}\n          style={{\n            transform: contentTransform,\n            WebkitTransform: contentTransform,\n          }}\n        >\n          {children}\n        </div>\n      </Touch>\n    </TouchRootContext.Provider>\n  );\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}