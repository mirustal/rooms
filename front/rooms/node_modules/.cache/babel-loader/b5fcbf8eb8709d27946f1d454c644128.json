{"ast":null,"code":"import { _ as _to_consumable_array } from \"@swc/helpers/_/_to_consumable_array\";\nfunction prepareSize(size) {\n  return {\n    url: size.url || size.src || \"\",\n    width: size.width,\n    height: size.height\n  };\n}\nfunction computeSize(sizes, minWidth) {\n  var minHeight = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;\n  // Do nothing if sizes contains only 1 item\n  if (sizes.length === 1) {\n    return sizes[0];\n  }\n  // Sorting in ascending order\n  var sorted = _to_consumable_array(sizes).sort(function (a, b) {\n    if (a.width < b.width) {\n      return -1;\n    }\n    if (a.width === b.width) {\n      return a.height > b.height ? 1 : -1;\n    }\n    return 1;\n  });\n  var matchesByWidth = sorted.filter(function (size) {\n    return size.width >= minWidth;\n  });\n  if (!matchesByWidth.length) {\n    // Biggest size\n    return sorted[sorted.length - 1];\n  }\n  if (!minHeight) {\n    return matchesByWidth[0];\n  }\n  // Searching by height\n  for (var i = 0; i < matchesByWidth.length; i++) {\n    var size = matchesByWidth[i];\n    if (size.height >= minHeight) {\n      return size;\n    }\n  }\n  // Sorting by height in ascending order\n  var sortedByHeight = matchesByWidth.sort(function (a, b) {\n    return a.height > b.height ? 1 : -1;\n  });\n  return sortedByHeight[sortedByHeight.length - 1];\n}\n/**\n * Searches for the smallest (?) suitable image from the sizes array.\n *\n * Or more precise, it returns:\n *   – if no suitable sizes (>= minWidth И >= minHeight): the biggest from all sizes;\n *   – there are any suitable (>= minWidth И >= minHeight): the smallest of the matching sizes;\n *\n * Returns null only in case of an empty/invalid array. The returned size can be smaller than minWidth or minHeight.\n *\n * The function doesn't take into about the retina screen (window.devicePixelRatio), so you have to calculate the right width/height from the outside to support it.\n *\n * WARN:\n * - does not reckon for letter-sizes (PhotosPhotoSizesType).\n * - does not know how to search for the \"nearest\" size, or the maximum image (there is a hack with the `Infinity` pass).\n *\n * @example\n *   getPhotoSize([{ width: 1, height: 1 }, { width: 3, height: 3 }], 1) // => 1,1\n *   getPhotoSize([{ width: 1, height: 1 }, { width: 3, height: 3 }], 2) // => 3,3\n *   getPhotoSize([{ width: 1, height: 1 }, { width: 3, height: 3 }], 4) // => 3,3\n *\n * See more examples in tests\n */\nexport function getPhotoSize(sizes, minWidth) {\n  var minHeight = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;\n  if (!Array.isArray(sizes) || !sizes.length) {\n    return null;\n  }\n  var size = computeSize(sizes, minWidth, minHeight);\n  return prepareSize(size);\n}","map":{"version":3,"names":["prepareSize","size","url","src","width","height","computeSize","sizes","minWidth","minHeight","arguments","length","sorted","_to_consumable_array","sort","a","b","matchesByWidth","filter","i","sortedByHeight","getPhotoSize","Array","isArray"],"sources":["../../src/getPhotoSize.ts"],"sourcesContent":["export interface PhotoSizeLike {\n  width: number;\n  height: number;\n  url?: string;\n  src?: string;\n}\n\nexport interface PhotoSize {\n  url: string;\n  width: number;\n  height: number;\n}\n\nfunction prepareSize(size: PhotoSizeLike): PhotoSize {\n  return {\n    url: size.url || size.src || '',\n    width: size.width,\n    height: size.height,\n  };\n}\n\nfunction computeSize(\n  sizes: PhotoSizeLike[],\n  minWidth: number,\n  minHeight: number | null = null,\n): PhotoSizeLike {\n  // Do nothing if sizes contains only 1 item\n  if (sizes.length === 1) {\n    return sizes[0];\n  }\n\n  // Sorting in ascending order\n  const sorted = [...sizes].sort((a, b) => {\n    if (a.width < b.width) {\n      return -1;\n    }\n\n    if (a.width === b.width) {\n      return a.height > b.height ? 1 : -1;\n    }\n\n    return 1;\n  });\n\n  const matchesByWidth = sorted.filter((size) => size.width >= minWidth);\n  if (!matchesByWidth.length) {\n    // Biggest size\n    return sorted[sorted.length - 1];\n  }\n\n  if (!minHeight) {\n    return matchesByWidth[0];\n  }\n\n  // Searching by height\n  for (let i = 0; i < matchesByWidth.length; i++) {\n    const size = matchesByWidth[i];\n    if (size.height >= minHeight) {\n      return size;\n    }\n  }\n\n  // Sorting by height in ascending order\n  const sortedByHeight = matchesByWidth.sort((a, b) => (a.height > b.height ? 1 : -1));\n\n  return sortedByHeight[sortedByHeight.length - 1];\n}\n\n/**\n * Searches for the smallest (?) suitable image from the sizes array.\n *\n * Or more precise, it returns:\n *   – if no suitable sizes (>= minWidth И >= minHeight): the biggest from all sizes;\n *   – there are any suitable (>= minWidth И >= minHeight): the smallest of the matching sizes;\n *\n * Returns null only in case of an empty/invalid array. The returned size can be smaller than minWidth or minHeight.\n *\n * The function doesn't take into about the retina screen (window.devicePixelRatio), so you have to calculate the right width/height from the outside to support it.\n *\n * WARN:\n * - does not reckon for letter-sizes (PhotosPhotoSizesType).\n * - does not know how to search for the \"nearest\" size, or the maximum image (there is a hack with the `Infinity` pass).\n *\n * @example\n *   getPhotoSize([{ width: 1, height: 1 }, { width: 3, height: 3 }], 1) // => 1,1\n *   getPhotoSize([{ width: 1, height: 1 }, { width: 3, height: 3 }], 2) // => 3,3\n *   getPhotoSize([{ width: 1, height: 1 }, { width: 3, height: 3 }], 4) // => 3,3\n *\n * See more examples in tests\n */\nexport function getPhotoSize(\n  sizes: PhotoSizeLike[],\n  minWidth: number,\n  minHeight: number | null = null,\n): PhotoSize | null {\n  if (!Array.isArray(sizes) || !sizes.length) {\n    return null;\n  }\n\n  const size = computeSize(sizes, minWidth, minHeight);\n\n  return prepareSize(size);\n}\n"],"mappings":";AAaA,SAASA,YAAYC,IAAmB;EACtC,OAAO;IACLC,GAAA,EAAKD,IAAA,CAAKC,GAAG,IAAID,IAAA,CAAKE,GAAG,IAAI;IAC7BC,KAAA,EAAOH,IAAA,CAAKG,KAAK;IACjBC,MAAA,EAAQJ,IAAA,CAAKI;EACf;AACF;AAEA,SAASC,YACPC,KAAsB,EACtBC,QAAgB;MAChBC,SAAA,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,iBAAAA,SAAA,MAA2B;EAE3B;EACA,IAAIH,KAAA,CAAMI,MAAM,KAAK,GAAG;IACtB,OAAOJ,KAAK,CAAC,EAAE;EACjB;EAEA;EACA,IAAMK,MAAA,GAASC,oBAAC,CAAGN,KAAA,EAAOO,IAAI,CAAC,UAACC,CAAA,EAAGC,CAAA;IACjC,IAAID,CAAA,CAAEX,KAAK,GAAGY,CAAA,CAAEZ,KAAK,EAAE;MACrB,OAAO,CAAC;IACV;IAEA,IAAIW,CAAA,CAAEX,KAAK,KAAKY,CAAA,CAAEZ,KAAK,EAAE;MACvB,OAAOW,CAAA,CAAEV,MAAM,GAAGW,CAAA,CAAEX,MAAM,GAAG,IAAI,CAAC;IACpC;IAEA,OAAO;EACT;EAEA,IAAMY,cAAA,GAAiBL,MAAA,CAAOM,MAAM,CAAC,UAACjB,IAAA;WAASA,IAAA,CAAKG,KAAK,IAAII,QAAA;;EAC7D,IAAI,CAACS,cAAA,CAAeN,MAAM,EAAE;IAC1B;IACA,OAAOC,MAAM,CAACA,MAAA,CAAOD,MAAM,GAAG,EAAE;EAClC;EAEA,IAAI,CAACF,SAAA,EAAW;IACd,OAAOQ,cAAc,CAAC,EAAE;EAC1B;EAEA;EACA,KAAK,IAAIE,CAAA,GAAI,GAAGA,CAAA,GAAIF,cAAA,CAAeN,MAAM,EAAEQ,CAAA,IAAK;IAC9C,IAAMlB,IAAA,GAAOgB,cAAc,CAACE,CAAA,CAAE;IAC9B,IAAIlB,IAAA,CAAKI,MAAM,IAAII,SAAA,EAAW;MAC5B,OAAOR,IAAA;IACT;EACF;EAEA;EACA,IAAMmB,cAAA,GAAiBH,cAAA,CAAeH,IAAI,CAAC,UAACC,CAAA,EAAGC,CAAA;WAAOD,CAAA,CAAEV,MAAM,GAAGW,CAAA,CAAEX,MAAM,GAAG,IAAI,CAAC;;EAEjF,OAAOe,cAAc,CAACA,cAAA,CAAeT,MAAM,GAAG,EAAE;AAClD;AAEA;;;;;;;;;;;;;;;;;;;;;;AAsBA,OAAO,SAASU,aACdd,KAAsB,EACtBC,QAAgB;MAChBC,SAAA,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,iBAAAA,SAAA,MAA2B;EAE3B,IAAI,CAACY,KAAA,CAAMC,OAAO,CAAChB,KAAA,KAAU,CAACA,KAAA,CAAMI,MAAM,EAAE;IAC1C,OAAO;EACT;EAEA,IAAMV,IAAA,GAAOK,WAAA,CAAYC,KAAA,EAAOC,QAAA,EAAUC,SAAA;EAE1C,OAAOT,WAAA,CAAYC,IAAA;AACrB"},"metadata":{},"sourceType":"module"}